[
  {
    "objectID": "simulation/huygens.html",
    "href": "simulation/huygens.html",
    "title": "Transmission of Huygens’ Surface",
    "section": "",
    "text": "Important Questions to answer:\n\nWhy do we need a normalizing run? (FDTD 101)\nWhy is there a mismatch between td.FreqRange.wvl0 and td.C_0 / td.FreqRange.freq0\n\nHuygens’ Metasurface Paper Link\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport tidy3d as td\nimport tidy3d.web as web\n\n\nPreconditions\n\n# 0 Define a FreqRange object with desired wavelengths\nfr = td.FreqRange.from_wvl_interval(wvl_min=1.1, wvl_max=1.6)\nN = 301 # num_points\n\n\n# 1 Computational domain size\nh = 0.220  # Height of cylinder\nspc = 2\nLz = spc + h + h + spc\n\nPx = Py = P = 0.666 # periodicity\nsim_size = [Px, Py, Lz]\n\n\n# 2 Grid Specifications\ndl = P / 32\nhorizontal_grid = td.UniformGrid(dl=dl)\nvertical_grid = td.AutoGrid(min_steps_per_wvl=32)\ngrid_spec=td.GridSpec(\n    grid_x=horizontal_grid,\n    grid_y=horizontal_grid,\n    grid_z=vertical_grid,\n)\n\n\n# 3 Structures\nr = 0.242  # radius of the cylinder\nn_Si = 3.5\nSi = td.Medium(permittivity=n_Si**2, name='Si')\ncylinder = td.Structure(\n    geometry=td.Cylinder(center=[0, 0, h / 2], radius=r, length=h, axis=2), medium=Si\n)\n\n# Spin_on glass + substrate\nn_glass = 1.4\nn_SiO2 = 1.45\nglass = td.Medium(permittivity=n_glass**2, name='glass')\nSiO2 = td.Medium(permittivity=n_SiO2**2, name='oxide')\n\nsubstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,-Lz/2),\n        size=(td.inf,td.inf,2 * (spc+h))\n    ),\n    medium=SiO2,\n    name='substrate'\n)\n\nglass = td.Structure(\n    geometry=td.Box(\n        center=(0,0,Lz/2),\n        size=(td.inf,td.inf,2 * (spc+h))\n    ),\n    medium=glass,\n    name='superstrate'\n)\n\n# Polymer\nn_polymer = 1.66\npolymer = td.Structure(\n    geometry=td.Box(\n        center=(0,0,0),\n        size=(td.inf,td.inf,td.inf)\n    ),\n    medium=td.Medium(permittivity=n_polymer**2, name='polymer'),\n    name='polymer'\n)\n\n\n# 4 Sources\nsource = td.PlaneWave(\n    source_time=fr.to_gaussian_pulse(),\n    size=(td.inf, td.inf, 0),\n    center=(0, 0, Lz/2 - spc + 2 * dl),\n    direction=\"-\",\n    pol_angle=0\n)\n\n\n# 5 Monitor\nmonitor = td.FluxMonitor(\n    center=(0, 0, -Lz/2 + spc - 2*dl),\n    size=(td.inf, td.inf, 0),\n    freqs=fr.freqs(N),\n    name=\"flux\"\n)\n\n\n# 6 Run Time\nbandwidth = fr.fmax - fr.fmin\nrun_time= 50 / bandwidth\n\n\n# 7 Boundary Condition\nbc = td.BoundarySpec(\n    x=td.Boundary.periodic(), \n    y=td.Boundary.periodic(), \n    z=td.Boundary.pml()\n)\n\n\n\nSimulation\n\nsim_empty=td.Simulation(\n    size=sim_size,\n    grid_spec=grid_spec,\n    structures=[substrate, glass],\n    sources=[source],\n    monitors=[monitor],\n    run_time=run_time,\n    boundary_spec=bc\n)\n\n\nsim_actual = td.Simulation(\n    size=sim_size,\n    grid_spec=grid_spec,\n    structures=[substrate, glass, cylinder],\n    sources=[source],\n    monitors=[monitor],\n    run_time=run_time,\n    boundary_spec=bc\n)\n\n\nfig, (ax1,ax2,ax3) = plt.subplots(1, 3, figsize=(10, 6))\nsim_actual.plot_eps(x=0, ax=ax1)\nsim_actual.plot_eps(y=0, ax=ax2)\nsim_actual.plot_eps(z=0, ax=ax3)\n\n\n\n\n\n\n\n\n\nsims = {\n    \"norm\": sim_empty,\n    \"actual\": sim_actual,\n}\n\nbatch = web.Batch(simulations=sims, verbose=True)\n\n\nbatch_data = batch.run(path_dir=\"data\")\n\n\n\n\n\n\n\n00:11:07 UTC Started working on Batch containing 2 tasks.                       \n\n\n\n             Maximum FlexCredit cost: 0.050 for the whole batch.                \n\n\n\n             Use 'Batch.real_cost()' to get the billed FlexCredit cost after the\n             Batch has completed.                                               \n\n\n\n\n\n\n00:11:08 UTC Batch complete.                                                    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPostprocess\n\n35 seconds to run both simulations\nresults are stored inside batch_data\n\n\nT = batch_data[\"actual\"][\"flux\"].flux / batch_data[\"norm\"][\"flux\"].flux\n\n\n# plot transmission, compare to paper results, look similar\nfig, ax = plt.subplots(1, 1, figsize=(6, 4.5))\nplt.plot(fr.freqs(N), T, \"r\", label=\"T\")\nplt.xlabel(r\"Frequency ($Hz$)\")\nplt.ylabel(\"Magnitude\")\nplt.ylim(0, 1)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n# plot transmission, compare to paper results, look similar\nfig, ax = plt.subplots(1, 1, figsize=(6, 4.5))\nplt.plot(td.C_0 / fr.freqs(N) * 1000, T, \"r\", label=\"T\")\nplt.xlabel(r\"wavelength ($nm$)\")\nplt.ylabel(\"Magnitude\")\nplt.ylim(0, 1)\nplt.legend()\nplt.show()",
    "crumbs": [
      "Simulation",
      "Transmission of Huygens' Surface"
    ]
  },
  {
    "objectID": "simulation/huygens.slides.html#preconditions",
    "href": "simulation/huygens.slides.html#preconditions",
    "title": "Transmission of Huygens’ Surface",
    "section": "Preconditions",
    "text": "Preconditions\n\n# 0 Define a FreqRange object with desired wavelengths\nfr = td.FreqRange.from_wvl_interval(wvl_min=1.1, wvl_max=1.6)\nN = 301 # num_points\n\n\n# 1 Computational domain size\nh = 0.220  # Height of cylinder\nspc = 2\nLz = spc + h + h + spc\n\nPx = Py = P = 0.666 # periodicity\nsim_size = [Px, Py, Lz]\n\n\n# 2 Grid Specifications\ndl = P / 32\nhorizontal_grid = td.UniformGrid(dl=dl)\nvertical_grid = td.AutoGrid(min_steps_per_wvl=32)\ngrid_spec=td.GridSpec(\n    grid_x=horizontal_grid,\n    grid_y=horizontal_grid,\n    grid_z=vertical_grid,\n)\n\n\n# 3 Structures\nr = 0.242  # radius of the cylinder\nn_Si = 3.5\nSi = td.Medium(permittivity=n_Si**2, name='Si')\ncylinder = td.Structure(\n    geometry=td.Cylinder(center=[0, 0, h / 2], radius=r, length=h, axis=2), medium=Si\n)\n\n# Spin_on glass + substrate\nn_glass = 1.4\nn_SiO2 = 1.45\nglass = td.Medium(permittivity=n_glass**2, name='glass')\nSiO2 = td.Medium(permittivity=n_SiO2**2, name='oxide')\n\nsubstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,-Lz/2),\n        size=(td.inf,td.inf,2 * (spc+h))\n    ),\n    medium=SiO2,\n    name='substrate'\n)\n\nglass = td.Structure(\n    geometry=td.Box(\n        center=(0,0,Lz/2),\n        size=(td.inf,td.inf,2 * (spc+h))\n    ),\n    medium=glass,\n    name='superstrate'\n)\n\n# Polymer\nn_polymer = 1.66\npolymer = td.Structure(\n    geometry=td.Box(\n        center=(0,0,0),\n        size=(td.inf,td.inf,td.inf)\n    ),\n    medium=td.Medium(permittivity=n_polymer**2, name='polymer'),\n    name='polymer'\n)\n\n\n# 4 Sources\nsource = td.PlaneWave(\n    source_time=fr.to_gaussian_pulse(),\n    size=(td.inf, td.inf, 0),\n    center=(0, 0, Lz/2 - spc + 2 * dl),\n    direction=\"-\",\n    pol_angle=0\n)\n\n\n# 5 Monitor\nmonitor = td.FluxMonitor(\n    center=(0, 0, -Lz/2 + spc - 2*dl),\n    size=(td.inf, td.inf, 0),\n    freqs=fr.freqs(N),\n    name=\"flux\"\n)\n\n\n# 6 Run Time\nbandwidth = fr.fmax - fr.fmin\nrun_time= 50 / bandwidth\n\n\n# 7 Boundary Condition\nbc = td.BoundarySpec(\n    x=td.Boundary.periodic(), \n    y=td.Boundary.periodic(), \n    z=td.Boundary.pml()\n)"
  },
  {
    "objectID": "simulation/huygens.slides.html#simulation",
    "href": "simulation/huygens.slides.html#simulation",
    "title": "Transmission of Huygens’ Surface",
    "section": "Simulation",
    "text": "Simulation\n\nsim_empty=td.Simulation(\n    size=sim_size,\n    grid_spec=grid_spec,\n    structures=[substrate, glass],\n    sources=[source],\n    monitors=[monitor],\n    run_time=run_time,\n    boundary_spec=bc\n)\n\n\nsim_actual = td.Simulation(\n    size=sim_size,\n    grid_spec=grid_spec,\n    structures=[substrate, glass, cylinder],\n    sources=[source],\n    monitors=[monitor],\n    run_time=run_time,\n    boundary_spec=bc\n)\n\n\nfig, (ax1,ax2,ax3) = plt.subplots(1, 3, figsize=(10, 6))\nsim_actual.plot_eps(x=0, ax=ax1)\nsim_actual.plot_eps(y=0, ax=ax2)\nsim_actual.plot_eps(z=0, ax=ax3)\n\n\n\nsims = {\n    \"norm\": sim_empty,\n    \"actual\": sim_actual,\n}\n\nbatch = web.Batch(simulations=sims, verbose=True)\n\n\nbatch_data = batch.run(path_dir=\"data\")\n\n\n\n\n\n\n\n00:11:07 UTC Started working on Batch containing 2 tasks.                       \n\n\n\n             Maximum FlexCredit cost: 0.050 for the whole batch.                \n\n\n\n             Use 'Batch.real_cost()' to get the billed FlexCredit cost after the\n             Batch has completed.                                               \n\n\n\n\n\n\n00:11:08 UTC Batch complete."
  },
  {
    "objectID": "simulation/huygens.slides.html#postprocess",
    "href": "simulation/huygens.slides.html#postprocess",
    "title": "Transmission of Huygens’ Surface",
    "section": "Postprocess",
    "text": "Postprocess\n\n35 seconds to run both simulations\nresults are stored inside batch_data\n\n\nT = batch_data[\"actual\"][\"flux\"].flux / batch_data[\"norm\"][\"flux\"].flux\n\n\n# plot transmission, compare to paper results, look similar\nfig, ax = plt.subplots(1, 1, figsize=(6, 4.5))\nplt.plot(fr.freqs(N), T, \"r\", label=\"T\")\nplt.xlabel(r\"Frequency ($Hz$)\")\nplt.ylabel(\"Magnitude\")\nplt.ylim(0, 1)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n# plot transmission, compare to paper results, look similar\nfig, ax = plt.subplots(1, 1, figsize=(6, 4.5))\nplt.plot(td.C_0 / fr.freqs(N) * 1000, T, \"r\", label=\"T\")\nplt.xlabel(r\"wavelength ($nm$)\")\nplt.ylabel(\"Magnitude\")\nplt.ylim(0, 1)\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "simulation/tidy3d.html",
    "href": "simulation/tidy3d.html",
    "title": "Learning Tidy3D",
    "section": "",
    "text": "FDTD method allows you to compute the evolution of electromagnetic field in the time domain.\nGiven some device \\epsilon(\\vec{r}) and an incident field or current source \\vec{J}(\\vec{r}, t), internally, FDTD solves these maxwell’s equations:\n\\nabla \\times \\vec{E}(\\vec{r}, t) = -\\mu_0 \\frac{\\vec{H}(\\vec{r}, t)}{dt} \\tag{1}\n\\nabla \\times \\vec{H}(\\vec{r}, t) = \\epsilon(\\vec{r}) \\epsilon_0 \\frac{d\\vec{E}(\\vec{r}, t)}{dt} + \\vec{J}(\\vec{r}, t) \\tag{2}\n\n\n\nField Update\n\n\n\nThe diagram is from Simulation Documentation\n\n\n\n\nThese software packages should be imported everytime you start a tidy3D project:\nimport tidy3d as td # Main package\nimport tidy3d.web as web # Used to run the simulation\nimport matplotlib.pyplot as plt # Used for plotting results\nimport numpy as np # Used for numerical calculations\n\n\n\nBefore the simulation, we have to define some key parameters of the electromagnetic waves that we will use across the simulation:\nlambda_range = (1.1, 1.6)   # wavelength range (µm)\nfreqs = (td.C_0 / lambda_range[1], td.C_0 / lambda_range[0])  # frequency range\nfreq0 = np.mean(freqs)      # center frequency\nlda0 = td.C_0 / freq0       # center wavelength\nbandwidth = 0.38            # normalized bandwidth\nfreqw = bandwidth * (freqs[1] - freqs[0])  # bandwidth in Hz\nNote: All numbers in tidy3d are in microns (\\mu m)\n\n\n\nHere’s how to simulate something:\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # inputs\n)\nThe most basic way of running the simulation is using the web object we imported from tidy3d:\n# Running a simulation\nsim1_data = web.run(simulation1, task_name='any-unique-name', path='data/descriptive-name.hdf5')\nSimulation data is stored as an HDF5 file at the file path you specify.\n\nSee Simulation Documentation for more information\n\n\n\n\nThe 7 required inputs are:\n\n\nComputational Domain Size\nGrid Specifications (Discretization size)\nStructures\nSources\nMonitors\nRun time\nBoundary Condition Specification\n\n\nWe will introduce these 7 parameters by simulating a huygen’s metasurface\n\nSee Simulation Documentation for more information\n\n\n\n\nSize in x, y, and z directions.\np = 0.666 #nm -&gt; Periodicity\nLx, Ly, Lz = p, p, 2 * lda0 \nsim_size = [Lx, Ly, Lz]\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = sim_size\n)\n\n\n\nSpecifications for the simulation grid along each of the three directions.\n# Define Grid size\nspec = td.GridSpec.auto(min_steps_per_wvl=40, wavelength=lda0)\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = (x, y, z),\n    grid_spec=spec,\n    \n)\n\nTypically, the size of a unit cell is \\frac{\\lambda}{20}\n\n\ntd.GridSpec contains many functions to help define the grid, the most commonly used are:\ntd.GridSpec.uniform(dl=grid_size)\ntd.GridSpec.auto(min_steps_per_wvl=40, wavelength=lda0)\n\nuniform - Use the same Uniform 1D grid along each of the three directions.\n\ndl (float) – Grid size for uniform grid generation.\n\nauto - Use the same non-uniform grid along each of the three directions.\n\nmin_steps_per_wvl(ConstrainedFloatValue = 10.0) – Minimal number of steps per wavelength in each medium.\nwavelength (float) – Wavelength to use for the step size and for dispersive media epsilon.\n\n\n\n\n\ntd.Structure is the meat of the simulation. It defines a physical object that interacts with the electromagnetic fields. The structures field is a tuple of Structure objects that you create.\n# set up simulation\nsim = td.Simulation(\n    size=sim_size,\n    grid_spec=spec,\n    structures=[superstrate, substrate, cylinder],\n\n# set up simulation\ntd.Structure(\n   # inputs\n)\nA structure needs two inputs at least: - geometry (td.Box, td.Cylinder, td.Sphere, td.TriangleMesh (STL file), etc.) - medium Mediums define the optical properties of the materials within the simulation. (e.g. td.Medium)\n\nAccording to the paper on huygen’s metasurface, I defined these four structures:\nt = 2  # thickness of the substrate # THIS SHOULD BE CHANGED TO INFINITE\nsubstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,-t/2),\n        size=(td.inf,td.inf,t)\n    ),\n    medium=td.Medium(permittivity=1.45**2, name='oxide'),\n    name='substrate'\n)\nsuperstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,t/2),\n        size=(td.inf,td.inf,t)\n    ),\n    medium=td.Medium(permittivity=1.4**2, name='glass'),\n    name='superstrate'\n)\npolymer = td.Structure(\n    geometry=td.Box(\n        center=(0,0,0),\n        size=(td.inf,td.inf,2*t)\n    ),\n    medium=td.Medium(permittivity=1.66**2, name='polymer'),\n    name='polymer'\n)\n# construct the silicon resonator\ncylinder = td.Structure(\n    geometry=td.Cylinder(center=[0, 0, h / 2], radius=r, length=h, axis=2), medium=td.Medium(permittivity=3.5**2, name='Si')\n)\n\n\n\nTuple of electric current sources injecting fields into the simulation. Common ones are:\nPlane Wave - Uniform current distribution on an infinite extent plane. (Doc)\npulse = GaussianPulse(freq0=200e12, fwidth=20e12)\npw_source = PlaneWave(size=(inf,0,inf), source_time=pulse, pol_angle=0.1, direction='+')\nPoint Dipole - Uniform current source with a zero size. (Doc)\npulse = td.GaussianPulse(freq0=200e12, fwidth=20e12)\npt_dipole = td.PointDipole(center=(1,2,3), source_time=pulse, polarization='Ex')\nSee documentation for Other Sources\n\nIn this case, I defined one plane wave source:\n# add a plane wave source\nplane_wave = td.PlaneWave(\n    source_time=td.GaussianPulse(freq0=freq0, fwidth=0.5 * freqw),\n    size=(td.inf, td.inf, 0),\n    center=(0, 0, 0.3 * lda0),\n    direction=\"-\",\n    pol_angle=0,\n)\n\n\n\nTuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.\nSee Other monitors\n\n\n\nTotal electromagnetic evolution time in seconds.\n\n\n\nSpecification of boundary conditions along each dimension. If None, PML boundary conditions are applied on all sides.\n\n\n\nTuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectively. Each element can be 0 (no symmetry), 1 (even, i.e. ‘PMC’ symmetry) or -1 (odd, i.e. ‘PEC’ symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.\nSymmetry can be used to greatly reduce the computational cost –&gt;",
    "crumbs": [
      "Simulation",
      "Learning Tidy3D"
    ]
  },
  {
    "objectID": "simulation/tidy3d.html#introduction-to-tidy3d",
    "href": "simulation/tidy3d.html#introduction-to-tidy3d",
    "title": "Learning Tidy3D",
    "section": "",
    "text": "FDTD method allows you to compute the evolution of electromagnetic field in the time domain.\nGiven some device \\epsilon(\\vec{r}) and an incident field or current source \\vec{J}(\\vec{r}, t), internally, FDTD solves these maxwell’s equations:\n\\nabla \\times \\vec{E}(\\vec{r}, t) = -\\mu_0 \\frac{\\vec{H}(\\vec{r}, t)}{dt} \\tag{1}\n\\nabla \\times \\vec{H}(\\vec{r}, t) = \\epsilon(\\vec{r}) \\epsilon_0 \\frac{d\\vec{E}(\\vec{r}, t)}{dt} + \\vec{J}(\\vec{r}, t) \\tag{2}\n\n\n\nField Update\n\n\n\nThe diagram is from Simulation Documentation\n\n\n\n\nThese software packages should be imported everytime you start a tidy3D project:\nimport tidy3d as td # Main package\nimport tidy3d.web as web # Used to run the simulation\nimport matplotlib.pyplot as plt # Used for plotting results\nimport numpy as np # Used for numerical calculations\n\n\n\nBefore the simulation, we have to define some key parameters of the electromagnetic waves that we will use across the simulation:\nlambda_range = (1.1, 1.6)   # wavelength range (µm)\nfreqs = (td.C_0 / lambda_range[1], td.C_0 / lambda_range[0])  # frequency range\nfreq0 = np.mean(freqs)      # center frequency\nlda0 = td.C_0 / freq0       # center wavelength\nbandwidth = 0.38            # normalized bandwidth\nfreqw = bandwidth * (freqs[1] - freqs[0])  # bandwidth in Hz\nNote: All numbers in tidy3d are in microns (\\mu m)\n\n\n\nHere’s how to simulate something:\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # inputs\n)\nThe most basic way of running the simulation is using the web object we imported from tidy3d:\n# Running a simulation\nsim1_data = web.run(simulation1, task_name='any-unique-name', path='data/descriptive-name.hdf5')\nSimulation data is stored as an HDF5 file at the file path you specify.\n\nSee Simulation Documentation for more information\n\n\n\n\nThe 7 required inputs are:\n\n\nComputational Domain Size\nGrid Specifications (Discretization size)\nStructures\nSources\nMonitors\nRun time\nBoundary Condition Specification\n\n\nWe will introduce these 7 parameters by simulating a huygen’s metasurface\n\nSee Simulation Documentation for more information\n\n\n\n\nSize in x, y, and z directions.\np = 0.666 #nm -&gt; Periodicity\nLx, Ly, Lz = p, p, 2 * lda0 \nsim_size = [Lx, Ly, Lz]\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = sim_size\n)\n\n\n\nSpecifications for the simulation grid along each of the three directions.\n# Define Grid size\nspec = td.GridSpec.auto(min_steps_per_wvl=40, wavelength=lda0)\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = (x, y, z),\n    grid_spec=spec,\n    \n)\n\nTypically, the size of a unit cell is \\frac{\\lambda}{20}\n\n\ntd.GridSpec contains many functions to help define the grid, the most commonly used are:\ntd.GridSpec.uniform(dl=grid_size)\ntd.GridSpec.auto(min_steps_per_wvl=40, wavelength=lda0)\n\nuniform - Use the same Uniform 1D grid along each of the three directions.\n\ndl (float) – Grid size for uniform grid generation.\n\nauto - Use the same non-uniform grid along each of the three directions.\n\nmin_steps_per_wvl(ConstrainedFloatValue = 10.0) – Minimal number of steps per wavelength in each medium.\nwavelength (float) – Wavelength to use for the step size and for dispersive media epsilon.\n\n\n\n\n\ntd.Structure is the meat of the simulation. It defines a physical object that interacts with the electromagnetic fields. The structures field is a tuple of Structure objects that you create.\n# set up simulation\nsim = td.Simulation(\n    size=sim_size,\n    grid_spec=spec,\n    structures=[superstrate, substrate, cylinder],\n\n# set up simulation\ntd.Structure(\n   # inputs\n)\nA structure needs two inputs at least: - geometry (td.Box, td.Cylinder, td.Sphere, td.TriangleMesh (STL file), etc.) - medium Mediums define the optical properties of the materials within the simulation. (e.g. td.Medium)\n\nAccording to the paper on huygen’s metasurface, I defined these four structures:\nt = 2  # thickness of the substrate # THIS SHOULD BE CHANGED TO INFINITE\nsubstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,-t/2),\n        size=(td.inf,td.inf,t)\n    ),\n    medium=td.Medium(permittivity=1.45**2, name='oxide'),\n    name='substrate'\n)\nsuperstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,t/2),\n        size=(td.inf,td.inf,t)\n    ),\n    medium=td.Medium(permittivity=1.4**2, name='glass'),\n    name='superstrate'\n)\npolymer = td.Structure(\n    geometry=td.Box(\n        center=(0,0,0),\n        size=(td.inf,td.inf,2*t)\n    ),\n    medium=td.Medium(permittivity=1.66**2, name='polymer'),\n    name='polymer'\n)\n# construct the silicon resonator\ncylinder = td.Structure(\n    geometry=td.Cylinder(center=[0, 0, h / 2], radius=r, length=h, axis=2), medium=td.Medium(permittivity=3.5**2, name='Si')\n)\n\n\n\nTuple of electric current sources injecting fields into the simulation. Common ones are:\nPlane Wave - Uniform current distribution on an infinite extent plane. (Doc)\npulse = GaussianPulse(freq0=200e12, fwidth=20e12)\npw_source = PlaneWave(size=(inf,0,inf), source_time=pulse, pol_angle=0.1, direction='+')\nPoint Dipole - Uniform current source with a zero size. (Doc)\npulse = td.GaussianPulse(freq0=200e12, fwidth=20e12)\npt_dipole = td.PointDipole(center=(1,2,3), source_time=pulse, polarization='Ex')\nSee documentation for Other Sources\n\nIn this case, I defined one plane wave source:\n# add a plane wave source\nplane_wave = td.PlaneWave(\n    source_time=td.GaussianPulse(freq0=freq0, fwidth=0.5 * freqw),\n    size=(td.inf, td.inf, 0),\n    center=(0, 0, 0.3 * lda0),\n    direction=\"-\",\n    pol_angle=0,\n)\n\n\n\nTuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.\nSee Other monitors\n\n\n\nTotal electromagnetic evolution time in seconds.\n\n\n\nSpecification of boundary conditions along each dimension. If None, PML boundary conditions are applied on all sides.\n\n\n\nTuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectively. Each element can be 0 (no symmetry), 1 (even, i.e. ‘PMC’ symmetry) or -1 (odd, i.e. ‘PEC’ symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.\nSymmetry can be used to greatly reduce the computational cost –&gt;",
    "crumbs": [
      "Simulation",
      "Learning Tidy3D"
    ]
  },
  {
    "objectID": "simulation/tidy3d.slides.html#introduction",
    "href": "simulation/tidy3d.slides.html#introduction",
    "title": "Learning Tidy3D",
    "section": "Introduction",
    "text": "Introduction\nFDTD method allows you to compute the evolution of electromagnetic field in the time domain.\nGiven some device \\epsilon(\\vec{r}) and an incident field or current source \\vec{J}(\\vec{r}, t), internally, FDTD solves these maxwell’s equations:\n\\nabla \\times \\vec{E}(\\vec{r}, t) = -\\mu_0 \\frac{\\vec{H}(\\vec{r}, t)}{dt} \\tag{1}\n\\nabla \\times \\vec{H}(\\vec{r}, t) = \\epsilon(\\vec{r}) \\epsilon_0 \\frac{d\\vec{E}(\\vec{r}, t)}{dt} + \\vec{J}(\\vec{r}, t) \\tag{2}\n\nField Update\nThe diagram is from Simulation Documentation"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#starting-tidy3d",
    "href": "simulation/tidy3d.slides.html#starting-tidy3d",
    "title": "Learning Tidy3D",
    "section": "Starting Tidy3D",
    "text": "Starting Tidy3D\nThese software packages should be imported everytime you start a tidy3D project:\nimport tidy3d as td # Main package\nimport tidy3d.web as web # Used to run the simulation\nimport matplotlib.pyplot as plt # Used for plotting results\nimport numpy as np # Used for numerical calculations"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#before-simulation",
    "href": "simulation/tidy3d.slides.html#before-simulation",
    "title": "Learning Tidy3D",
    "section": "Before Simulation",
    "text": "Before Simulation\nBefore the simulation, we have to define some key parameters of the electromagnetic waves that we will use across the simulation:\nlambda_range = (1.1, 1.6)   # wavelength range (µm)\nfreqs = (td.C_0 / lambda_range[1], td.C_0 / lambda_range[0])  # frequency range\nfreq0 = np.mean(freqs)      # center frequency\nlda0 = td.C_0 / freq0       # center wavelength\nbandwidth = 0.38            # normalized bandwidth\nfreqw = bandwidth * (freqs[1] - freqs[0])  # bandwidth in Hz\nNote: All numbers in tidy3d are in microns (\\mu m)"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#basic-workflow",
    "href": "simulation/tidy3d.slides.html#basic-workflow",
    "title": "Learning Tidy3D",
    "section": "Basic Workflow",
    "text": "Basic Workflow\nHere’s how to simulate something:\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # inputs\n)\nThe most basic way of running the simulation is using the web object we imported from tidy3d:\n# Running a simulation\nsim1_data = web.run(simulation1, task_name='any-unique-name', path='data/descriptive-name.hdf5')\nSimulation data is stored as an HDF5 file at the file path you specify.\n\nSee Simulation Documentation for more information"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#simulation-inputs",
    "href": "simulation/tidy3d.slides.html#simulation-inputs",
    "title": "Learning Tidy3D",
    "section": "Simulation Inputs",
    "text": "Simulation Inputs\nThe 7 required inputs are:\n\nComputational Domain Size\nGrid Specifications (Discretization size)\nStructures\nSources\nMonitors\nRun time\nBoundary Condition Specification\n\nWe will introduce these 7 parameters by simulating a huygen’s metasurface\n\nSee Simulation Documentation for more information"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#computational-domain-size",
    "href": "simulation/tidy3d.slides.html#computational-domain-size",
    "title": "Learning Tidy3D",
    "section": "1 Computational Domain Size",
    "text": "1 Computational Domain Size\nSize in x, y, and z directions.\np = 0.666 #nm -&gt; Periodicity\nLx, Ly, Lz = p, p, 2 * lda0 \nsim_size = [Lx, Ly, Lz]\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = sim_size\n)"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#grid-specifications",
    "href": "simulation/tidy3d.slides.html#grid-specifications",
    "title": "Learning Tidy3D",
    "section": "2 Grid Specifications",
    "text": "2 Grid Specifications\nSpecifications for the simulation grid along each of the three directions.\n# Define Grid size\nspec = td.GridSpec.auto(min_steps_per_wvl=40, wavelength=lda0)\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = (x, y, z),\n    grid_spec=spec,\n    \n)\n\nTypically, the size of a unit cell is \\frac{\\lambda}{20}"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#structures",
    "href": "simulation/tidy3d.slides.html#structures",
    "title": "Learning Tidy3D",
    "section": "3 Structures",
    "text": "3 Structures\ntd.Structure is the meat of the simulation. It defines a physical object that interacts with the electromagnetic fields. The structures field is a tuple of Structure objects that you create.\n# set up simulation\nsim = td.Simulation(\n    size=sim_size,\n    grid_spec=spec,\n    structures=[superstrate, substrate, cylinder],"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#sources",
    "href": "simulation/tidy3d.slides.html#sources",
    "title": "Learning Tidy3D",
    "section": "4 Sources",
    "text": "4 Sources\nTuple of electric current sources injecting fields into the simulation. Common ones are:\nPlane Wave - Uniform current distribution on an infinite extent plane. (Doc)\npulse = GaussianPulse(freq0=200e12, fwidth=20e12)\npw_source = PlaneWave(size=(inf,0,inf), source_time=pulse, pol_angle=0.1, direction='+')\nPoint Dipole - Uniform current source with a zero size. (Doc)\npulse = td.GaussianPulse(freq0=200e12, fwidth=20e12)\npt_dipole = td.PointDipole(center=(1,2,3), source_time=pulse, polarization='Ex')\nSee documentation for Other Sources"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#monitors",
    "href": "simulation/tidy3d.slides.html#monitors",
    "title": "Learning Tidy3D",
    "section": "5 Monitors",
    "text": "5 Monitors\nTuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.\nSee Other monitors"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#run-time",
    "href": "simulation/tidy3d.slides.html#run-time",
    "title": "Learning Tidy3D",
    "section": "6 Run time",
    "text": "6 Run time\nTotal electromagnetic evolution time in seconds."
  },
  {
    "objectID": "simulation/tidy3d.slides.html#boundary-condition-specification",
    "href": "simulation/tidy3d.slides.html#boundary-condition-specification",
    "title": "Learning Tidy3D",
    "section": "7 Boundary Condition Specification",
    "text": "7 Boundary Condition Specification\nSpecification of boundary conditions along each dimension. If None, PML boundary conditions are applied on all sides."
  },
  {
    "objectID": "simulation/tidy3d.slides.html#bonus-symmetry",
    "href": "simulation/tidy3d.slides.html#bonus-symmetry",
    "title": "Learning Tidy3D",
    "section": "Bonus: Symmetry",
    "text": "Bonus: Symmetry\nTuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectively. Each element can be 0 (no symmetry), 1 (even, i.e. ‘PMC’ symmetry) or -1 (odd, i.e. ‘PEC’ symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.\nSymmetry can be used to greatly reduce the computational cost –&gt;"
  },
  {
    "objectID": "log.html",
    "href": "log.html",
    "title": "Work Log",
    "section": "",
    "text": "8/28/2025 Thursday\n\n\nTidy3D Huygen’s metasurface simulation redo\nRead Fundamentals of Photonics Ch 1, 2, 6\nRead Boyd NLO Ch 1\n\n\n\n8/27/2025 Wednesday\n\n\nTidy3D Python Tutorial 1 and 2\nNonlinear Optics course\nAdvanced Optics course\n\n\n\n\nTidy3D Learning\nFDTD 101:\n\nIntroduction to FDTD Simulation\nUsing FDTD to compute transmission spectrum\nMode Injection\nModeling Dispersive materials in FDTD\nIntroduction to PML\nTimestep size and CFL conditions\nNumerical Dispersion in FDTD\nDielectric constant assignment on Yee Grids\nSubpixel Averaging\n\nTidy3D Python:\n\nBasics\nMediums\nStructures\nGrid Specifications\nBoundary Conditions and Symmetry\nSources\nData visualization and Postprocessing",
    "crumbs": [
      "Work Log"
    ]
  },
  {
    "objectID": "log.slides.html#tidy3d-learning",
    "href": "log.slides.html#tidy3d-learning",
    "title": "Work Log",
    "section": "Tidy3D Learning",
    "text": "Tidy3D Learning\nFDTD 101:\n\nIntroduction to FDTD Simulation\nUsing FDTD to compute transmission spectrum\nMode Injection\nModeling Dispersive materials in FDTD\nIntroduction to PML\nTimestep size and CFL conditions\nNumerical Dispersion in FDTD\nDielectric constant assignment on Yee Grids\nSubpixel Averaging\n\nTidy3D Python:\n\nBasics\nMediums\nStructures\nGrid Specifications\nBoundary Conditions and Symmetry\nSources\nData visualization and Postprocessing"
  },
  {
    "objectID": "courses/optics.html",
    "href": "courses/optics.html",
    "title": "Learning Optics",
    "section": "",
    "text": "Picturing light as rays is useful for predicting imaging properties.\nAs \\lambda \\rightarrow 0, Maxwell equation’s become the eikonal equation, which governs ray direction in a medium with a varying n(\\vec{r}).\nFermat’s principle is deduced from eikonal equation.\nSnell’s law is derived from fermat’s principle.\n\n\n\nWave equation in isotropic medium:\n\\nabla^2 \\vec{E}(\\vec{r}, t) + \\frac{[n(\\vec{r})]^2 \\omega^2}{c^2} \\vec{E}(\\vec{r}, t) = 0\nTrial solution:\n\\vec{E}(\\vec{r}, t) = \\vec{E}_0 e^{i[k_{vac} R(\\vec{r}) - \\omega t]}, k_{vac} = \\frac{\\omega}{c} \\left( \\frac{rad}{m} \\right)\nWe plug trial solution in, perform laplacian, arrange terms, and make the approximation that \\frac{1}{k_{vac}} = \\frac{\\lambda_{vac}}{2 \\pi} \\rightarrow 0, we get the simplified wave equation\n[\\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) - [n(\\vec{r})]^2] \\vec{E}_0(\\vec{r}) = 0\n\\implies \\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) = [n(\\vec{r})]^2\n\\implies \\boxed{ \\nabla R(\\vec{r}) = n(\\vec{r}) \\hat{s}(\\vec{r}) }\nIf R(\\vec{r}) (length) is real, no absorption or amplification. R(\\vec{r}) = constant is one wavefront. \\nabla R(\\vec{r}) is the local direction of propagation. \\hat{s} is unit vector in direction of energy flow. Rays are collection vectors \\hat{s}.\n\n\n\nCurl of eikonal function is\n\\nabla \\times [\\nabla R(\\vec{r})] = \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0 \nIntegrating over open surface A, we get\n\\int_{A} \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0  \\tag{}\nApply Stoke’s Theorem, we have\n\\oint_{C} n \\hat{s} \\cdot d\\vec{l} = 0\n\\implies \\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l}\nNotice that\n\\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l} = \\min{\\int_{A}^{B} n d \\vec{l}}\nWe define Optical Path Length as\n\\boxed{OPL = \\int_{A}^{B} n dl}\nAnd Fermat’s Theorem minimizes travel time,\n\\delta t = \\frac{OPL}{c}\n\n\n\nPropagation of rays through optical systems can be approximated as paraxial, nearly parallel to the axis of these systems.\nParaxial ray theory predicts stability of laser cavities, to see if ray drift away from optical axis.\n\n\n\n\n\n\nConstruction to prove Snell’s Law\n\n\nConstrained minimization problem: Minimize $n_1 d_1 _1 + $",
    "crumbs": [
      "Courses",
      "Learning Optics"
    ]
  },
  {
    "objectID": "courses/optics.html#ray-optics",
    "href": "courses/optics.html#ray-optics",
    "title": "Learning Optics",
    "section": "",
    "text": "Picturing light as rays is useful for predicting imaging properties.\nAs \\lambda \\rightarrow 0, Maxwell equation’s become the eikonal equation, which governs ray direction in a medium with a varying n(\\vec{r}).\nFermat’s principle is deduced from eikonal equation.\nSnell’s law is derived from fermat’s principle.\n\n\n\nWave equation in isotropic medium:\n\\nabla^2 \\vec{E}(\\vec{r}, t) + \\frac{[n(\\vec{r})]^2 \\omega^2}{c^2} \\vec{E}(\\vec{r}, t) = 0\nTrial solution:\n\\vec{E}(\\vec{r}, t) = \\vec{E}_0 e^{i[k_{vac} R(\\vec{r}) - \\omega t]}, k_{vac} = \\frac{\\omega}{c} \\left( \\frac{rad}{m} \\right)\nWe plug trial solution in, perform laplacian, arrange terms, and make the approximation that \\frac{1}{k_{vac}} = \\frac{\\lambda_{vac}}{2 \\pi} \\rightarrow 0, we get the simplified wave equation\n[\\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) - [n(\\vec{r})]^2] \\vec{E}_0(\\vec{r}) = 0\n\\implies \\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) = [n(\\vec{r})]^2\n\\implies \\boxed{ \\nabla R(\\vec{r}) = n(\\vec{r}) \\hat{s}(\\vec{r}) }\nIf R(\\vec{r}) (length) is real, no absorption or amplification. R(\\vec{r}) = constant is one wavefront. \\nabla R(\\vec{r}) is the local direction of propagation. \\hat{s} is unit vector in direction of energy flow. Rays are collection vectors \\hat{s}.\n\n\n\nCurl of eikonal function is\n\\nabla \\times [\\nabla R(\\vec{r})] = \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0 \nIntegrating over open surface A, we get\n\\int_{A} \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0  \\tag{}\nApply Stoke’s Theorem, we have\n\\oint_{C} n \\hat{s} \\cdot d\\vec{l} = 0\n\\implies \\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l}\nNotice that\n\\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l} = \\min{\\int_{A}^{B} n d \\vec{l}}\nWe define Optical Path Length as\n\\boxed{OPL = \\int_{A}^{B} n dl}\nAnd Fermat’s Theorem minimizes travel time,\n\\delta t = \\frac{OPL}{c}\n\n\n\nPropagation of rays through optical systems can be approximated as paraxial, nearly parallel to the axis of these systems.\nParaxial ray theory predicts stability of laser cavities, to see if ray drift away from optical axis.\n\n\n\n\n\n\nConstruction to prove Snell’s Law\n\n\nConstrained minimization problem: Minimize $n_1 d_1 _1 + $",
    "crumbs": [
      "Courses",
      "Learning Optics"
    ]
  },
  {
    "objectID": "courses/optics.html#citations",
    "href": "courses/optics.html#citations",
    "title": "Learning Optics",
    "section": "Citations",
    "text": "Citations\n[1] Saleh, B. E. A., & Teich, M. C. (2019). Fundamentals of photonics (3rd ed.). Wiley. [2] Peatross, Justin, and Michael Ware. Physics of Light and Optics. 2015 ed., January 31, 2025 revision, Department of Physics, Brigham Young University. optics.byu.edu.",
    "crumbs": [
      "Courses",
      "Learning Optics"
    ]
  },
  {
    "objectID": "courses/optics.slides.html#introduction",
    "href": "courses/optics.slides.html#introduction",
    "title": "Learning Optics",
    "section": "Introduction",
    "text": "Introduction\nPicturing light as rays is useful for predicting imaging properties.\nAs \\lambda \\rightarrow 0, Maxwell equation’s become the eikonal equation, which governs ray direction in a medium with a varying n(\\vec{r}).\nFermat’s principle is deduced from eikonal equation.\nSnell’s law is derived from fermat’s principle."
  },
  {
    "objectID": "courses/optics.slides.html#the-eikonal-equation",
    "href": "courses/optics.slides.html#the-eikonal-equation",
    "title": "Learning Optics",
    "section": "The Eikonal Equation",
    "text": "The Eikonal Equation\nWave equation in isotropic medium:\n\\nabla^2 \\vec{E}(\\vec{r}, t) + \\frac{[n(\\vec{r})]^2 \\omega^2}{c^2} \\vec{E}(\\vec{r}, t) = 0\nTrial solution:\n\\vec{E}(\\vec{r}, t) = \\vec{E}_0 e^{i[k_{vac} R(\\vec{r}) - \\omega t]}, k_{vac} = \\frac{\\omega}{c} \\left( \\frac{rad}{m} \\right)\nWe plug trial solution in, perform laplacian, arrange terms, and make the approximation that \\frac{1}{k_{vac}} = \\frac{\\lambda_{vac}}{2 \\pi} \\rightarrow 0, we get the simplified wave equation\n[\\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) - [n(\\vec{r})]^2] \\vec{E}_0(\\vec{r}) = 0\n\\implies \\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) = [n(\\vec{r})]^2\n\\implies \\boxed{ \\nabla R(\\vec{r}) = n(\\vec{r}) \\hat{s}(\\vec{r}) }\nIf R(\\vec{r}) (length) is real, no absorption or amplification. R(\\vec{r}) = constant is one wavefront. \\nabla R(\\vec{r}) is the local direction of propagation. \\hat{s} is unit vector in direction of energy flow. Rays are collection vectors \\hat{s}."
  },
  {
    "objectID": "courses/optics.slides.html#fermats-principle",
    "href": "courses/optics.slides.html#fermats-principle",
    "title": "Learning Optics",
    "section": "Fermat’s Principle",
    "text": "Fermat’s Principle\nCurl of eikonal function is\n\\nabla \\times [\\nabla R(\\vec{r})] = \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0 \nIntegrating over open surface A, we get\n\\int_{A} \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0  \\tag{}\nApply Stoke’s Theorem, we have\n\\oint_{C} n \\hat{s} \\cdot d\\vec{l} = 0\n\\implies \\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l}\nNotice that\n\\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l} = \\min{\\int_{A}^{B} n d \\vec{l}}\nWe define Optical Path Length as\n\\boxed{OPL = \\int_{A}^{B} n dl}\nAnd Fermat’s Theorem minimizes travel time,\n\\delta t = \\frac{OPL}{c}"
  },
  {
    "objectID": "courses/optics.slides.html#paraxial-ray-theory",
    "href": "courses/optics.slides.html#paraxial-ray-theory",
    "title": "Learning Optics",
    "section": "Paraxial Ray Theory",
    "text": "Paraxial Ray Theory\nPropagation of rays through optical systems can be approximated as paraxial, nearly parallel to the axis of these systems.\nParaxial ray theory predicts stability of laser cavities, to see if ray drift away from optical axis."
  },
  {
    "objectID": "courses/optics.slides.html#proof-of-snells-law",
    "href": "courses/optics.slides.html#proof-of-snells-law",
    "title": "Learning Optics",
    "section": "Proof of Snell’s Law",
    "text": "Proof of Snell’s Law\n\nConstruction to prove Snell’s LawConstrained minimization problem: Minimize $n_1 d_1 _1 + $"
  },
  {
    "objectID": "index.slides.html#about-me",
    "href": "index.slides.html#about-me",
    "title": "Yankun (Alex) Meng",
    "section": "About Me",
    "text": "About Me\nI am a first-year PhD student in the Department of Electrical and Computer Engineering at Duke University, fortunate to be advised by Prof. Natalia M. Litchinitser.\nPreviously, I was an undergrad at Duke University Double majoring in Electrical and Computer Engineering and Computer Science."
  },
  {
    "objectID": "index.slides.html#news",
    "href": "index.slides.html#news",
    "title": "Yankun (Alex) Meng",
    "section": "News",
    "text": "News\n[August 2025] PhD started!\n[May 2025] Graduated from Duke Undergraduate"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Yankun (Alex) Meng",
    "section": "",
    "text": "About Me\nI am a first-year PhD student in the Department of Electrical and Computer Engineering at Duke University, fortunate to be advised by Prof. Natalia M. Litchinitser.\nPreviously, I was an undergrad at Duke University Double majoring in Electrical and Computer Engineering and Computer Science.\n\n\nNews\n[August 2025] PhD started!\n[May 2025] Graduated from Duke Undergraduate",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "simulation/numpy.slides.html#what-is-numpy",
    "href": "simulation/numpy.slides.html#what-is-numpy",
    "title": "Learning Numpy",
    "section": "What is NumPy?",
    "text": "What is NumPy?\nNumPy is a package for dealing with arrays that’s very fast and efficient.\nCreating array:\narr1 = np.array([3, 5, 7, 3]) # convert list to array\narr2 = np.zeros(10) # array with 10 zeroes\narr3 = np.ones(10) # array with 10 ones\narrR = np.random.random(10) # sample 10 numbers from uniform distribution\narrG = np.random.randn(10) # sample 10 numbers from normal distribution"
  },
  {
    "objectID": "simulation/numpy.slides.html#two-most-common-functions",
    "href": "simulation/numpy.slides.html#two-most-common-functions",
    "title": "Learning Numpy",
    "section": "Two most common functions",
    "text": "Two most common functions\nlinspace - values equally spaced apart given the number of values\narr = np.linspace(0, 10, 100) # from 0 to 10, 100 values\narrange - values equally spaced apart given the spacing\narr = np.arrange(0, 10, 0.02) # from 0 to 10, spacing of 0.02"
  },
  {
    "objectID": "simulation/numpy.slides.html#common-array-operation",
    "href": "simulation/numpy.slides.html#common-array-operation",
    "title": "Learning Numpy",
    "section": "Common Array Operation",
    "text": "Common Array Operation\nElement-wise operation\narr + 2     # addition\narr - 5     # subtraction\n2*arr       # multiplication\n1/arr       # division\narr % 5     # Modulus\nLet’s try to do the same element-wise operation but using functions:\ndef f(x):\n    return x**2 * np.sin(x) / np.exp(-x)\n\nx = np.linspace(0, 10, 100)\ny = f(x) # Element-wise application of f"
  },
  {
    "objectID": "simulation/numpy.slides.html#common-plotting",
    "href": "simulation/numpy.slides.html#common-plotting",
    "title": "Learning Numpy",
    "section": "Common Plotting",
    "text": "Common Plotting\nMost basic Plotting\nx = np.linspace(0, 1, 100)  # x-axis definition\ny = x**2                    # element-wise x^2\nplt.plot(x, x**2)           # plot(x, y)\nplt.show()                  # show the output\nHistogram\nplt.hist(arr) # plotting the array as histogram"
  },
  {
    "objectID": "simulation/numpy.slides.html#indexing-and-slicing",
    "href": "simulation/numpy.slides.html#indexing-and-slicing",
    "title": "Learning Numpy",
    "section": "Indexing and Slicing",
    "text": "Indexing and Slicing\nNormal Indexing\narr = np.array([2, 4, 6, 8, 10])\narr[2]   # return 6\narr[2:]  # return 6, 8, 10 (including index 2)\narr[:-2] # return 2, 4, 6 (exluding index -2)\narr[1:2] # return 4\nBoolean Indexing\narr &gt; 5 # return a boolean array with true or false as elemenets\narr[arr&gt;5] # filtering --&gt;  return the elements that are true\nUsing Boolean Indexing to filter data\nnames = np.array(['Jim', 'Luke', 'Josh', 'Pete'])\nfirst_letter_j = np.vectorize(lambda s: s[0])(names) == 'J'\nprint(names[first_letter_j]) # gets the names that have first letter as J\nNow what is this doing?"
  },
  {
    "objectID": "simulation/numpy.slides.html#what-is-that-doing",
    "href": "simulation/numpy.slides.html#what-is-that-doing",
    "title": "Learning Numpy",
    "section": "What is that doing?",
    "text": "What is that doing?\nfirst_letter_j = np.vectorize(lambda s: s[0])(names) == 'J'\nLambda Function\nf = lambda s: s[0]\nThis is a function that says give me a string and I’ll give you the first character of the string. Note that String is not an array in python, but it supports the same indexing operations as arrays.\nWhat is np.vectorize?\nIt creates a for-loop, applies the function func to every element in the array arr, and return the result as an array.\nnp.vectorize(func)(arr) # this is an array"
  },
  {
    "objectID": "simulation/numpy.slides.html#common-statistics-functions",
    "href": "simulation/numpy.slides.html#common-statistics-functions",
    "title": "Learning Numpy",
    "section": "Common Statistics Functions",
    "text": "Common Statistics Functions\narr = 2*np.random.randn(10000) + 10 # 2 times std dev with a shift of 10 to the right\\\nnp.mean(arr) # approx 10\nnp.std(arr) # approx 2\nnp.percentile(arr, 80) # 80% numbers less than this number"
  },
  {
    "objectID": "simulation/numpy.slides.html#integrals-and-derivatives",
    "href": "simulation/numpy.slides.html#integrals-and-derivatives",
    "title": "Learning Numpy",
    "section": "Integrals and Derivatives",
    "text": "Integrals and Derivatives\nx = np.linspace(1, 10, 100)\ny = 1/x**2 + np.sin(x)\nplt.plot(x, y)\nDerivatives\ndydx = np.gradient(y, x)\nIntegrals\nnp.cumsum([1, 2, 3, 4]) # return [1,3,6,10]\ny_int = np.cumsum(y) * (x[1] - x[0]) # int y dx"
  },
  {
    "objectID": "simulation/numpy.slides.html#resources-used",
    "href": "simulation/numpy.slides.html#resources-used",
    "title": "Learning Numpy",
    "section": "Resources Used",
    "text": "Resources Used\n\n[1] NumPy Tutorial\n[2] 100 numpy practice problems"
  },
  {
    "objectID": "simulation/numpy.html",
    "href": "simulation/numpy.html",
    "title": "Learning Numpy",
    "section": "",
    "text": "NumPy is a package for dealing with arrays that’s very fast and efficient.\nCreating array:\narr1 = np.array([3, 5, 7, 3]) # convert list to array\narr2 = np.zeros(10) # array with 10 zeroes\narr3 = np.ones(10) # array with 10 ones\narrR = np.random.random(10) # sample 10 numbers from uniform distribution\narrG = np.random.randn(10) # sample 10 numbers from normal distribution\n\n\n\nlinspace - values equally spaced apart given the number of values\narr = np.linspace(0, 10, 100) # from 0 to 10, 100 values\narrange - values equally spaced apart given the spacing\narr = np.arrange(0, 10, 0.02) # from 0 to 10, spacing of 0.02",
    "crumbs": [
      "Simulation",
      "Learning Numpy"
    ]
  },
  {
    "objectID": "simulation/numpy.html#introduction-and-basics",
    "href": "simulation/numpy.html#introduction-and-basics",
    "title": "Learning Numpy",
    "section": "",
    "text": "NumPy is a package for dealing with arrays that’s very fast and efficient.\nCreating array:\narr1 = np.array([3, 5, 7, 3]) # convert list to array\narr2 = np.zeros(10) # array with 10 zeroes\narr3 = np.ones(10) # array with 10 ones\narrR = np.random.random(10) # sample 10 numbers from uniform distribution\narrG = np.random.randn(10) # sample 10 numbers from normal distribution\n\n\n\nlinspace - values equally spaced apart given the number of values\narr = np.linspace(0, 10, 100) # from 0 to 10, 100 values\narrange - values equally spaced apart given the spacing\narr = np.arrange(0, 10, 0.02) # from 0 to 10, spacing of 0.02",
    "crumbs": [
      "Simulation",
      "Learning Numpy"
    ]
  },
  {
    "objectID": "simulation/numpy.html#array-manipulation",
    "href": "simulation/numpy.html#array-manipulation",
    "title": "Learning Numpy",
    "section": "Array Manipulation",
    "text": "Array Manipulation\n\nCommon Array Operation\nElement-wise operation\narr + 2     # addition\narr - 5     # subtraction\n2*arr       # multiplication\n1/arr       # division\narr % 5     # Modulus\nLet’s try to do the same element-wise operation but using functions:\ndef f(x):\n    return x**2 * np.sin(x) / np.exp(-x)\n\nx = np.linspace(0, 10, 100)\ny = f(x) # Element-wise application of f\n\n\nCommon Plotting\nMost basic Plotting\nx = np.linspace(0, 1, 100)  # x-axis definition\ny = x**2                    # element-wise x^2\nplt.plot(x, x**2)           # plot(x, y)\nplt.show()                  # show the output\nHistogram\nplt.hist(arr) # plotting the array as histogram\n\n\nIndexing and Slicing\nNormal Indexing\narr = np.array([2, 4, 6, 8, 10])\narr[2]   # return 6\narr[2:]  # return 6, 8, 10 (including index 2)\narr[:-2] # return 2, 4, 6 (exluding index -2)\narr[1:2] # return 4\nBoolean Indexing\narr &gt; 5 # return a boolean array with true or false as elemenets\narr[arr&gt;5] # filtering --&gt;  return the elements that are true\nUsing Boolean Indexing to filter data\nnames = np.array(['Jim', 'Luke', 'Josh', 'Pete'])\nfirst_letter_j = np.vectorize(lambda s: s[0])(names) == 'J'\nprint(names[first_letter_j]) # gets the names that have first letter as J\nNow what is this doing?\n\n\nWhat is that doing?\nfirst_letter_j = np.vectorize(lambda s: s[0])(names) == 'J'\nLambda Function\nf = lambda s: s[0]\nThis is a function that says give me a string and I’ll give you the first character of the string. Note that String is not an array in python, but it supports the same indexing operations as arrays.\nWhat is np.vectorize?\nIt creates a for-loop, applies the function func to every element in the array arr, and return the result as an array.\nnp.vectorize(func)(arr) # this is an array",
    "crumbs": [
      "Simulation",
      "Learning Numpy"
    ]
  },
  {
    "objectID": "simulation/numpy.html#calculus-statistical-functions",
    "href": "simulation/numpy.html#calculus-statistical-functions",
    "title": "Learning Numpy",
    "section": "Calculus / Statistical Functions",
    "text": "Calculus / Statistical Functions\n\nCommon Statistics Functions\narr = 2*np.random.randn(10000) + 10 # 2 times std dev with a shift of 10 to the right\\\nnp.mean(arr) # approx 10\nnp.std(arr) # approx 2\nnp.percentile(arr, 80) # 80% numbers less than this number\n\n\nIntegrals and Derivatives\nx = np.linspace(1, 10, 100)\ny = 1/x**2 + np.sin(x)\nplt.plot(x, y)\nDerivatives\ndydx = np.gradient(y, x)\nIntegrals\nnp.cumsum([1, 2, 3, 4]) # return [1,3,6,10]\ny_int = np.cumsum(y) * (x[1] - x[0]) # int y dx\n\n\nResources Used\n\n[1] NumPy Tutorial\n[2] 100 numpy practice problems",
    "crumbs": [
      "Simulation",
      "Learning Numpy"
    ]
  },
  {
    "objectID": "experiment.html",
    "href": "experiment.html",
    "title": "Yankun (Alex) Meng",
    "section": "",
    "text": "import tidy3d as td\nimport numpy as np\nimport matplotlib.pyplot as plt \nimport tidy3d.web as web\n\n\nweb.test()\n\n18:03:04 EDT Authentication configured successfully!"
  }
]