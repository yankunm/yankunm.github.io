[
  {
    "objectID": "tidy3d.html",
    "href": "tidy3d.html",
    "title": "Learning Tidy3D",
    "section": "",
    "text": "FDTD method allows you to compute the evolution of electromagnetic field in the time domain.\nGiven some device \\epsilon(\\vec{r}) and an incident field or current source \\vec{J}(\\vec{r}, t), internally, FDTD solves these maxwell’s equations:\n\\nabla \\times \\vec{E}(\\vec{r}, t) = -\\mu_0 \\frac{\\vec{H}(\\vec{r}, t)}{dt} \\tag{1}\n\\nabla \\times \\vec{H}(\\vec{r}, t) = \\epsilon(\\vec{r}) \\epsilon_0 \\frac{d\\vec{E}(\\vec{r}, t)}{dt} + \\vec{J}(\\vec{r}, t) \\tag{2}\n\n\n\nField Update\n\n\n\nThe diagram is from Simulation Documentation\n\n\n\n\nThese software packages should be imported everytime you start a tidy3D project:\nimport tidy3d as td # Main package\nimport tidy3d.web as web # Used to run the simulation\nimport matplotlib.pyplot as plt # Used for plotting results\nimport numpy as np # Used for numerical calculations\n\n\n\nBefore the simulation, we have to define some key parameters of the electromagnetic waves that we will use across the simulation:\nlambda_range = (1.1, 1.6)   # wavelength range (µm)\nfreqs = (td.C_0 / lambda_range[1], td.C_0 / lambda_range[0])  # frequency range\nfreq0 = np.mean(freqs)      # center frequency\nlda0 = td.C_0 / freq0       # center wavelength\nbandwidth = 0.38            # normalized bandwidth\nfreqw = bandwidth * (freqs[1] - freqs[0])  # bandwidth in Hz\nNote: All numbers in tidy3d are in microns (\\mu m)\n\n\n\nHere’s how to simulate something:\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # inputs\n)\nThe most basic way of running the simulation is using the web object we imported from tidy3d:\n# Running a simulation\nsim1_data = web.run(simulation1, task_name='any-unique-name', path='data/descriptive-name.hdf5')\nSimulation data is stored as an HDF5 file at the file path you specify.\n\nSee Simulation Documentation for more information\n\n\n\n\nThe 7 required inputs are:\n\n\nComputational Domain Size\nGrid Specifications (Discretization size)\nStructures\nSources\nMonitors\nRun time\nBoundary Condition Specification\n\n\nWe will introduce these 7 parameters by simulating a huygen’s metasurface\n\nSee Simulation Documentation for more information\n\n\n\n\nSize in x, y, and z directions.\np = 0.666 #nm -&gt; Periodicity\nLx, Ly, Lz = p, p, 2 * lda0 \nsim_size = [Lx, Ly, Lz]\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = sim_size\n)\n\n\n\nSpecifications for the simulation grid along each of the three directions.\n# Define Grid size\nspec = td.GridSpec.auto(min_steps_per_wvl=40, wavelength=lda0)\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = (x, y, z),\n    grid_spec=spec,\n    \n)\n\nTypically, the size of a unit cell is \\frac{\\lambda}{20}\n\n\ntd.GridSpec contains many functions to help define the grid, the most commonly used are:\ntd.GridSpec.uniform(dl=grid_size)\ntd.GridSpec.auto(min_steps_per_wvl=40, wavelength=lda0)\n\nuniform - Use the same Uniform 1D grid along each of the three directions.\n\ndl (float) – Grid size for uniform grid generation.\n\nauto - Use the same non-uniform grid along each of the three directions.\n\nmin_steps_per_wvl(ConstrainedFloatValue = 10.0) – Minimal number of steps per wavelength in each medium.\nwavelength (float) – Wavelength to use for the step size and for dispersive media epsilon.\n\n\n\n\n\ntd.Structure is the meat of the simulation. It defines a physical object that interacts with the electromagnetic fields. The structures field is a tuple of Structure objects that you create.\n# set up simulation\nsim = td.Simulation(\n    size=sim_size,\n    grid_spec=spec,\n    structures=[superstrate, substrate, cylinder],\n\n# set up simulation\ntd.Structure(\n   # inputs\n)\nA structure needs two inputs at least: - geometry (td.Box, td.Cylinder, td.Sphere, td.TriangleMesh (STL file), etc.) - medium Mediums define the optical properties of the materials within the simulation. (e.g. td.Medium)\n\nAccording to the paper on huygen’s metasurface, I defined these four structures:\nt = 2  # thickness of the substrate # THIS SHOULD BE CHANGED TO INFINITE\nsubstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,-t/2),\n        size=(td.inf,td.inf,t)\n    ),\n    medium=td.Medium(permittivity=1.45**2, name='oxide'),\n    name='substrate'\n)\nsuperstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,t/2),\n        size=(td.inf,td.inf,t)\n    ),\n    medium=td.Medium(permittivity=1.4**2, name='glass'),\n    name='superstrate'\n)\npolymer = td.Structure(\n    geometry=td.Box(\n        center=(0,0,0),\n        size=(td.inf,td.inf,2*t)\n    ),\n    medium=td.Medium(permittivity=1.66**2, name='polymer'),\n    name='polymer'\n)\n# construct the silicon resonator\ncylinder = td.Structure(\n    geometry=td.Cylinder(center=[0, 0, h / 2], radius=r, length=h, axis=2), medium=td.Medium(permittivity=3.5**2, name='Si')\n)\n\n\n\nTuple of electric current sources injecting fields into the simulation. Common ones are:\nPlane Wave - Uniform current distribution on an infinite extent plane. (Doc)\npulse = GaussianPulse(freq0=200e12, fwidth=20e12)\npw_source = PlaneWave(size=(inf,0,inf), source_time=pulse, pol_angle=0.1, direction='+')\nPoint Dipole - Uniform current source with a zero size. (Doc)\npulse = td.GaussianPulse(freq0=200e12, fwidth=20e12)\npt_dipole = td.PointDipole(center=(1,2,3), source_time=pulse, polarization='Ex')\nSee documentation for Other Sources\n\nIn this case, I defined one plane wave source:\n# add a plane wave source\nplane_wave = td.PlaneWave(\n    source_time=td.GaussianPulse(freq0=freq0, fwidth=0.5 * freqw),\n    size=(td.inf, td.inf, 0),\n    center=(0, 0, 0.3 * lda0),\n    direction=\"-\",\n    pol_angle=0,\n)\n\n\n\nTuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.\nSee Other monitors\n\n\n\nTotal electromagnetic evolution time in seconds.\n\n\n\nSpecification of boundary conditions along each dimension. If None, PML boundary conditions are applied on all sides.\n\n\n\nTuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectively. Each element can be 0 (no symmetry), 1 (even, i.e. ‘PMC’ symmetry) or -1 (odd, i.e. ‘PEC’ symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.\nSymmetry can be used to greatly reduce the computational cost –&gt;",
    "crumbs": [
      "Year 1",
      "Learning Tidy3D"
    ]
  },
  {
    "objectID": "tidy3d.html#introduction-to-tidy3d",
    "href": "tidy3d.html#introduction-to-tidy3d",
    "title": "Learning Tidy3D",
    "section": "",
    "text": "FDTD method allows you to compute the evolution of electromagnetic field in the time domain.\nGiven some device \\epsilon(\\vec{r}) and an incident field or current source \\vec{J}(\\vec{r}, t), internally, FDTD solves these maxwell’s equations:\n\\nabla \\times \\vec{E}(\\vec{r}, t) = -\\mu_0 \\frac{\\vec{H}(\\vec{r}, t)}{dt} \\tag{1}\n\\nabla \\times \\vec{H}(\\vec{r}, t) = \\epsilon(\\vec{r}) \\epsilon_0 \\frac{d\\vec{E}(\\vec{r}, t)}{dt} + \\vec{J}(\\vec{r}, t) \\tag{2}\n\n\n\nField Update\n\n\n\nThe diagram is from Simulation Documentation\n\n\n\n\nThese software packages should be imported everytime you start a tidy3D project:\nimport tidy3d as td # Main package\nimport tidy3d.web as web # Used to run the simulation\nimport matplotlib.pyplot as plt # Used for plotting results\nimport numpy as np # Used for numerical calculations\n\n\n\nBefore the simulation, we have to define some key parameters of the electromagnetic waves that we will use across the simulation:\nlambda_range = (1.1, 1.6)   # wavelength range (µm)\nfreqs = (td.C_0 / lambda_range[1], td.C_0 / lambda_range[0])  # frequency range\nfreq0 = np.mean(freqs)      # center frequency\nlda0 = td.C_0 / freq0       # center wavelength\nbandwidth = 0.38            # normalized bandwidth\nfreqw = bandwidth * (freqs[1] - freqs[0])  # bandwidth in Hz\nNote: All numbers in tidy3d are in microns (\\mu m)\n\n\n\nHere’s how to simulate something:\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # inputs\n)\nThe most basic way of running the simulation is using the web object we imported from tidy3d:\n# Running a simulation\nsim1_data = web.run(simulation1, task_name='any-unique-name', path='data/descriptive-name.hdf5')\nSimulation data is stored as an HDF5 file at the file path you specify.\n\nSee Simulation Documentation for more information\n\n\n\n\nThe 7 required inputs are:\n\n\nComputational Domain Size\nGrid Specifications (Discretization size)\nStructures\nSources\nMonitors\nRun time\nBoundary Condition Specification\n\n\nWe will introduce these 7 parameters by simulating a huygen’s metasurface\n\nSee Simulation Documentation for more information\n\n\n\n\nSize in x, y, and z directions.\np = 0.666 #nm -&gt; Periodicity\nLx, Ly, Lz = p, p, 2 * lda0 \nsim_size = [Lx, Ly, Lz]\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = sim_size\n)\n\n\n\nSpecifications for the simulation grid along each of the three directions.\n# Define Grid size\nspec = td.GridSpec.auto(min_steps_per_wvl=40, wavelength=lda0)\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = (x, y, z),\n    grid_spec=spec,\n    \n)\n\nTypically, the size of a unit cell is \\frac{\\lambda}{20}\n\n\ntd.GridSpec contains many functions to help define the grid, the most commonly used are:\ntd.GridSpec.uniform(dl=grid_size)\ntd.GridSpec.auto(min_steps_per_wvl=40, wavelength=lda0)\n\nuniform - Use the same Uniform 1D grid along each of the three directions.\n\ndl (float) – Grid size for uniform grid generation.\n\nauto - Use the same non-uniform grid along each of the three directions.\n\nmin_steps_per_wvl(ConstrainedFloatValue = 10.0) – Minimal number of steps per wavelength in each medium.\nwavelength (float) – Wavelength to use for the step size and for dispersive media epsilon.\n\n\n\n\n\ntd.Structure is the meat of the simulation. It defines a physical object that interacts with the electromagnetic fields. The structures field is a tuple of Structure objects that you create.\n# set up simulation\nsim = td.Simulation(\n    size=sim_size,\n    grid_spec=spec,\n    structures=[superstrate, substrate, cylinder],\n\n# set up simulation\ntd.Structure(\n   # inputs\n)\nA structure needs two inputs at least: - geometry (td.Box, td.Cylinder, td.Sphere, td.TriangleMesh (STL file), etc.) - medium Mediums define the optical properties of the materials within the simulation. (e.g. td.Medium)\n\nAccording to the paper on huygen’s metasurface, I defined these four structures:\nt = 2  # thickness of the substrate # THIS SHOULD BE CHANGED TO INFINITE\nsubstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,-t/2),\n        size=(td.inf,td.inf,t)\n    ),\n    medium=td.Medium(permittivity=1.45**2, name='oxide'),\n    name='substrate'\n)\nsuperstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,t/2),\n        size=(td.inf,td.inf,t)\n    ),\n    medium=td.Medium(permittivity=1.4**2, name='glass'),\n    name='superstrate'\n)\npolymer = td.Structure(\n    geometry=td.Box(\n        center=(0,0,0),\n        size=(td.inf,td.inf,2*t)\n    ),\n    medium=td.Medium(permittivity=1.66**2, name='polymer'),\n    name='polymer'\n)\n# construct the silicon resonator\ncylinder = td.Structure(\n    geometry=td.Cylinder(center=[0, 0, h / 2], radius=r, length=h, axis=2), medium=td.Medium(permittivity=3.5**2, name='Si')\n)\n\n\n\nTuple of electric current sources injecting fields into the simulation. Common ones are:\nPlane Wave - Uniform current distribution on an infinite extent plane. (Doc)\npulse = GaussianPulse(freq0=200e12, fwidth=20e12)\npw_source = PlaneWave(size=(inf,0,inf), source_time=pulse, pol_angle=0.1, direction='+')\nPoint Dipole - Uniform current source with a zero size. (Doc)\npulse = td.GaussianPulse(freq0=200e12, fwidth=20e12)\npt_dipole = td.PointDipole(center=(1,2,3), source_time=pulse, polarization='Ex')\nSee documentation for Other Sources\n\nIn this case, I defined one plane wave source:\n# add a plane wave source\nplane_wave = td.PlaneWave(\n    source_time=td.GaussianPulse(freq0=freq0, fwidth=0.5 * freqw),\n    size=(td.inf, td.inf, 0),\n    center=(0, 0, 0.3 * lda0),\n    direction=\"-\",\n    pol_angle=0,\n)\n\n\n\nTuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.\nSee Other monitors\n\n\n\nTotal electromagnetic evolution time in seconds.\n\n\n\nSpecification of boundary conditions along each dimension. If None, PML boundary conditions are applied on all sides.\n\n\n\nTuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectively. Each element can be 0 (no symmetry), 1 (even, i.e. ‘PMC’ symmetry) or -1 (odd, i.e. ‘PEC’ symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.\nSymmetry can be used to greatly reduce the computational cost –&gt;",
    "crumbs": [
      "Year 1",
      "Learning Tidy3D"
    ]
  },
  {
    "objectID": "tidy3d.slides.html#introduction",
    "href": "tidy3d.slides.html#introduction",
    "title": "Learning Tidy3D",
    "section": "Introduction",
    "text": "Introduction\nFDTD method allows you to compute the evolution of electromagnetic field in the time domain.\nGiven some device \\epsilon(\\vec{r}) and an incident field or current source \\vec{J}(\\vec{r}, t), internally, FDTD solves these maxwell’s equations:\n\\nabla \\times \\vec{E}(\\vec{r}, t) = -\\mu_0 \\frac{\\vec{H}(\\vec{r}, t)}{dt} \\tag{1}\n\\nabla \\times \\vec{H}(\\vec{r}, t) = \\epsilon(\\vec{r}) \\epsilon_0 \\frac{d\\vec{E}(\\vec{r}, t)}{dt} + \\vec{J}(\\vec{r}, t) \\tag{2}\n\nField Update\nThe diagram is from Simulation Documentation"
  },
  {
    "objectID": "tidy3d.slides.html#starting-tidy3d",
    "href": "tidy3d.slides.html#starting-tidy3d",
    "title": "Learning Tidy3D",
    "section": "Starting Tidy3D",
    "text": "Starting Tidy3D\nThese software packages should be imported everytime you start a tidy3D project:\nimport tidy3d as td # Main package\nimport tidy3d.web as web # Used to run the simulation\nimport matplotlib.pyplot as plt # Used for plotting results\nimport numpy as np # Used for numerical calculations"
  },
  {
    "objectID": "tidy3d.slides.html#before-simulation",
    "href": "tidy3d.slides.html#before-simulation",
    "title": "Learning Tidy3D",
    "section": "Before Simulation",
    "text": "Before Simulation\nBefore the simulation, we have to define some key parameters of the electromagnetic waves that we will use across the simulation:\nlambda_range = (1.1, 1.6)   # wavelength range (µm)\nfreqs = (td.C_0 / lambda_range[1], td.C_0 / lambda_range[0])  # frequency range\nfreq0 = np.mean(freqs)      # center frequency\nlda0 = td.C_0 / freq0       # center wavelength\nbandwidth = 0.38            # normalized bandwidth\nfreqw = bandwidth * (freqs[1] - freqs[0])  # bandwidth in Hz\nNote: All numbers in tidy3d are in microns (\\mu m)"
  },
  {
    "objectID": "tidy3d.slides.html#basic-workflow",
    "href": "tidy3d.slides.html#basic-workflow",
    "title": "Learning Tidy3D",
    "section": "Basic Workflow",
    "text": "Basic Workflow\nHere’s how to simulate something:\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # inputs\n)\nThe most basic way of running the simulation is using the web object we imported from tidy3d:\n# Running a simulation\nsim1_data = web.run(simulation1, task_name='any-unique-name', path='data/descriptive-name.hdf5')\nSimulation data is stored as an HDF5 file at the file path you specify.\n\nSee Simulation Documentation for more information"
  },
  {
    "objectID": "tidy3d.slides.html#simulation-inputs",
    "href": "tidy3d.slides.html#simulation-inputs",
    "title": "Learning Tidy3D",
    "section": "Simulation Inputs",
    "text": "Simulation Inputs\nThe 7 required inputs are:\n\nComputational Domain Size\nGrid Specifications (Discretization size)\nStructures\nSources\nMonitors\nRun time\nBoundary Condition Specification\n\nWe will introduce these 7 parameters by simulating a huygen’s metasurface\n\nSee Simulation Documentation for more information"
  },
  {
    "objectID": "tidy3d.slides.html#computational-domain-size",
    "href": "tidy3d.slides.html#computational-domain-size",
    "title": "Learning Tidy3D",
    "section": "1 Computational Domain Size",
    "text": "1 Computational Domain Size\nSize in x, y, and z directions.\np = 0.666 #nm -&gt; Periodicity\nLx, Ly, Lz = p, p, 2 * lda0 \nsim_size = [Lx, Ly, Lz]\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = sim_size\n)"
  },
  {
    "objectID": "tidy3d.slides.html#grid-specifications",
    "href": "tidy3d.slides.html#grid-specifications",
    "title": "Learning Tidy3D",
    "section": "2 Grid Specifications",
    "text": "2 Grid Specifications\nSpecifications for the simulation grid along each of the three directions.\n# Define Grid size\nspec = td.GridSpec.auto(min_steps_per_wvl=40, wavelength=lda0)\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = (x, y, z),\n    grid_spec=spec,\n    \n)\n\nTypically, the size of a unit cell is \\frac{\\lambda}{20}"
  },
  {
    "objectID": "tidy3d.slides.html#structures",
    "href": "tidy3d.slides.html#structures",
    "title": "Learning Tidy3D",
    "section": "3 Structures",
    "text": "3 Structures\ntd.Structure is the meat of the simulation. It defines a physical object that interacts with the electromagnetic fields. The structures field is a tuple of Structure objects that you create.\n# set up simulation\nsim = td.Simulation(\n    size=sim_size,\n    grid_spec=spec,\n    structures=[superstrate, substrate, cylinder],"
  },
  {
    "objectID": "tidy3d.slides.html#sources",
    "href": "tidy3d.slides.html#sources",
    "title": "Learning Tidy3D",
    "section": "4 Sources",
    "text": "4 Sources\nTuple of electric current sources injecting fields into the simulation. Common ones are:\nPlane Wave - Uniform current distribution on an infinite extent plane. (Doc)\npulse = GaussianPulse(freq0=200e12, fwidth=20e12)\npw_source = PlaneWave(size=(inf,0,inf), source_time=pulse, pol_angle=0.1, direction='+')\nPoint Dipole - Uniform current source with a zero size. (Doc)\npulse = td.GaussianPulse(freq0=200e12, fwidth=20e12)\npt_dipole = td.PointDipole(center=(1,2,3), source_time=pulse, polarization='Ex')\nSee documentation for Other Sources"
  },
  {
    "objectID": "tidy3d.slides.html#monitors",
    "href": "tidy3d.slides.html#monitors",
    "title": "Learning Tidy3D",
    "section": "5 Monitors",
    "text": "5 Monitors\nTuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.\nSee Other monitors"
  },
  {
    "objectID": "tidy3d.slides.html#run-time",
    "href": "tidy3d.slides.html#run-time",
    "title": "Learning Tidy3D",
    "section": "6 Run time",
    "text": "6 Run time\nTotal electromagnetic evolution time in seconds."
  },
  {
    "objectID": "tidy3d.slides.html#boundary-condition-specification",
    "href": "tidy3d.slides.html#boundary-condition-specification",
    "title": "Learning Tidy3D",
    "section": "7 Boundary Condition Specification",
    "text": "7 Boundary Condition Specification\nSpecification of boundary conditions along each dimension. If None, PML boundary conditions are applied on all sides."
  },
  {
    "objectID": "tidy3d.slides.html#bonus-symmetry",
    "href": "tidy3d.slides.html#bonus-symmetry",
    "title": "Learning Tidy3D",
    "section": "Bonus: Symmetry",
    "text": "Bonus: Symmetry\nTuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectively. Each element can be 0 (no symmetry), 1 (even, i.e. ‘PMC’ symmetry) or -1 (odd, i.e. ‘PEC’ symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.\nSymmetry can be used to greatly reduce the computational cost –&gt;"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Yankun (Alex) Meng",
    "section": "",
    "text": "About Me\nI am an incoming PhD student in the Department of Electrical and Computer Engineering at Duke University, fortunate to be advised by Prof. Natalia M. Litchinitser.\nPreviously, I was an undergrad at Duke University Double majoring in Electrical and Computer Engineering and Computer Science.\n\n\nNews\n[August 2025] PhD started!\n[May 2025] Graduated from Duke Undergraduate",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.slides.html#about-me",
    "href": "index.slides.html#about-me",
    "title": "Yankun (Alex) Meng",
    "section": "About Me",
    "text": "About Me\nI am an incoming PhD student in the Department of Electrical and Computer Engineering at Duke University, fortunate to be advised by Prof. Natalia M. Litchinitser.\nPreviously, I was an undergrad at Duke University Double majoring in Electrical and Computer Engineering and Computer Science."
  },
  {
    "objectID": "index.slides.html#news",
    "href": "index.slides.html#news",
    "title": "Yankun (Alex) Meng",
    "section": "News",
    "text": "News\n[August 2025] PhD started!\n[May 2025] Graduated from Duke Undergraduate"
  },
  {
    "objectID": "optics.slides.html#introduction",
    "href": "optics.slides.html#introduction",
    "title": "Learning Optics",
    "section": "Introduction",
    "text": "Introduction\nPicturing light as rays is useful for predicting imaging properties.\nAs \\lambda \\rightarrow 0, Maxwell equation’s become the eikonal equation, which governs ray direction in a medium with a varying n(\\vec{r}).\nFermat’s principle is deduced from eikonal equation.\nSnell’s law is derived from fermat’s principle."
  },
  {
    "objectID": "optics.slides.html#eikonal-equation",
    "href": "optics.slides.html#eikonal-equation",
    "title": "Learning Optics",
    "section": "Eikonal Equation",
    "text": "Eikonal Equation\n\\nabla^2 \\vec{E}(\\vec{r}, t) + \\frac{[n(\\vec{r})]^2 \\omega^2}{c^2} \\vec{E}(\\vec{r}, t) = 0 \\tag{wave equation in isotropic medium} \\vec{E}(\\vec{r}, t) = \\vec{E}_0 e^{i[k_{vac} R(\\vec{r}) - \\omega t]}, k_{vac} = \\frac{\\omega}{c} \\left( \\frac{rad}{m} \\right) \\tag{trial solution}\nWe plug trial solution in, perform laplacian, arrange terms, and make the approximation that \\frac{1}{k_{vac}} = \\frac{\\lambda_{vac}}{2 \\pi} \\rightarrow 0, we get\n[\\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) - [n(\\vec{r})]^2] \\vec{E}_0(\\vec{r}) = 0 \\tag{Simplified wave equation}\n\\implies \\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) = [n(\\vec{r})]^2\n\\implies \\boxed{ \\nabla R(\\vec{r}) = n(\\vec{r}) \\hat{s}(\\vec{r}) } \\tag{eikonal function}\nIf R(\\vec{r}) (length) is real, no absorption or amplification. R(\\vec{r}) = constant is one wavefront. \\nabla R(\\vec{r}) is the local direction of propagation. \\hat{s} is unit vector in direction of energy flow. Rays are collection vectors \\hat{s}."
  },
  {
    "objectID": "optics.slides.html#fermats-principle",
    "href": "optics.slides.html#fermats-principle",
    "title": "Learning Optics",
    "section": "Fermat’s Principle",
    "text": "Fermat’s Principle\n\\nabla \\times [\\nabla R(\\vec{r})] = \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0  \\tag{curl of eikonal function}\n\\int_{A} \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0  \\tag{integrate over open surface A}\n\\oint_{C} n \\hat{s} \\cdot d\\vec{l} = 0 \\tag{By Stoke's Theorem}\n\\implies \\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l} \\text{is independent of path}\nNotice that\n\\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l} = \\min{\\int_{A}^{B} n d \\vec{l}}\nWe define Optical Path Length as\n\\boxed{OPL = \\frac{A}{B} n dl}\nAnd Fermat’s Theorem minimizes\n\\delta t = \\frac{OPL}{c} \\tag{travel time}"
  },
  {
    "objectID": "optics.slides.html#paraxial-ray-theory",
    "href": "optics.slides.html#paraxial-ray-theory",
    "title": "Learning Optics",
    "section": "Paraxial Ray Theory",
    "text": "Paraxial Ray Theory\nPropagation of rays through optical systems can be approximated as paraxial, nearly parallel to the axis of these systems.\nParaxial ray theory predicts stability of laser cavities, to see if ray drift away from optical axis."
  },
  {
    "objectID": "optics.slides.html#proof-of-snells-law",
    "href": "optics.slides.html#proof-of-snells-law",
    "title": "Learning Optics",
    "section": "Proof of Snell’s Law",
    "text": "Proof of Snell’s Law\n\nConstruction to prove Snell’s LawConstrained minimization problem: Minimize $n_1 d_1 _1 + $"
  },
  {
    "objectID": "optics.html",
    "href": "optics.html",
    "title": "Learning Optics",
    "section": "",
    "text": "Picturing light as rays is useful for predicting imaging properties.\nAs \\lambda \\rightarrow 0, Maxwell equation’s become the eikonal equation, which governs ray direction in a medium with a varying n(\\vec{r}).\nFermat’s principle is deduced from eikonal equation.\nSnell’s law is derived from fermat’s principle.\n\n\n\n\\nabla^2 \\vec{E}(\\vec{r}, t) + \\frac{[n(\\vec{r})]^2 \\omega^2}{c^2} \\vec{E}(\\vec{r}, t) = 0 \\tag{wave equation in isotropic medium} \\vec{E}(\\vec{r}, t) = \\vec{E}_0 e^{i[k_{vac} R(\\vec{r}) - \\omega t]}, k_{vac} = \\frac{\\omega}{c} \\left( \\frac{rad}{m} \\right) \\tag{trial solution}\nWe plug trial solution in, perform laplacian, arrange terms, and make the approximation that \\frac{1}{k_{vac}} = \\frac{\\lambda_{vac}}{2 \\pi} \\rightarrow 0, we get\n[\\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) - [n(\\vec{r})]^2] \\vec{E}_0(\\vec{r}) = 0 \\tag{Simplified wave equation}\n\\implies \\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) = [n(\\vec{r})]^2\n\\implies \\boxed{ \\nabla R(\\vec{r}) = n(\\vec{r}) \\hat{s}(\\vec{r}) } \\tag{eikonal function}\nIf R(\\vec{r}) (length) is real, no absorption or amplification. R(\\vec{r}) = constant is one wavefront. \\nabla R(\\vec{r}) is the local direction of propagation. \\hat{s} is unit vector in direction of energy flow. Rays are collection vectors \\hat{s}.\n\n\n\n\\nabla \\times [\\nabla R(\\vec{r})] = \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0  \\tag{curl of eikonal function}\n\\int_{A} \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0  \\tag{integrate over open surface A}\n\\oint_{C} n \\hat{s} \\cdot d\\vec{l} = 0 \\tag{By Stoke's Theorem}\n\\implies \\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l} \\text{is independent of path}\nNotice that\n\\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l} = \\min{\\int_{A}^{B} n d \\vec{l}}\nWe define Optical Path Length as\n\\boxed{OPL = \\frac{A}{B} n dl}\nAnd Fermat’s Theorem minimizes\n\\delta t = \\frac{OPL}{c} \\tag{travel time}\n\n\n\nPropagation of rays through optical systems can be approximated as paraxial, nearly parallel to the axis of these systems.\nParaxial ray theory predicts stability of laser cavities, to see if ray drift away from optical axis.\n\n\n\n\n\n\nConstruction to prove Snell’s Law\n\n\nConstrained minimization problem: Minimize $n_1 d_1 _1 + $",
    "crumbs": [
      "Year 1",
      "Learning Optics"
    ]
  },
  {
    "objectID": "optics.html#ray-optics",
    "href": "optics.html#ray-optics",
    "title": "Learning Optics",
    "section": "",
    "text": "Picturing light as rays is useful for predicting imaging properties.\nAs \\lambda \\rightarrow 0, Maxwell equation’s become the eikonal equation, which governs ray direction in a medium with a varying n(\\vec{r}).\nFermat’s principle is deduced from eikonal equation.\nSnell’s law is derived from fermat’s principle.\n\n\n\n\\nabla^2 \\vec{E}(\\vec{r}, t) + \\frac{[n(\\vec{r})]^2 \\omega^2}{c^2} \\vec{E}(\\vec{r}, t) = 0 \\tag{wave equation in isotropic medium} \\vec{E}(\\vec{r}, t) = \\vec{E}_0 e^{i[k_{vac} R(\\vec{r}) - \\omega t]}, k_{vac} = \\frac{\\omega}{c} \\left( \\frac{rad}{m} \\right) \\tag{trial solution}\nWe plug trial solution in, perform laplacian, arrange terms, and make the approximation that \\frac{1}{k_{vac}} = \\frac{\\lambda_{vac}}{2 \\pi} \\rightarrow 0, we get\n[\\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) - [n(\\vec{r})]^2] \\vec{E}_0(\\vec{r}) = 0 \\tag{Simplified wave equation}\n\\implies \\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) = [n(\\vec{r})]^2\n\\implies \\boxed{ \\nabla R(\\vec{r}) = n(\\vec{r}) \\hat{s}(\\vec{r}) } \\tag{eikonal function}\nIf R(\\vec{r}) (length) is real, no absorption or amplification. R(\\vec{r}) = constant is one wavefront. \\nabla R(\\vec{r}) is the local direction of propagation. \\hat{s} is unit vector in direction of energy flow. Rays are collection vectors \\hat{s}.\n\n\n\n\\nabla \\times [\\nabla R(\\vec{r})] = \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0  \\tag{curl of eikonal function}\n\\int_{A} \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0  \\tag{integrate over open surface A}\n\\oint_{C} n \\hat{s} \\cdot d\\vec{l} = 0 \\tag{By Stoke's Theorem}\n\\implies \\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l} \\text{is independent of path}\nNotice that\n\\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l} = \\min{\\int_{A}^{B} n d \\vec{l}}\nWe define Optical Path Length as\n\\boxed{OPL = \\frac{A}{B} n dl}\nAnd Fermat’s Theorem minimizes\n\\delta t = \\frac{OPL}{c} \\tag{travel time}\n\n\n\nPropagation of rays through optical systems can be approximated as paraxial, nearly parallel to the axis of these systems.\nParaxial ray theory predicts stability of laser cavities, to see if ray drift away from optical axis.\n\n\n\n\n\n\nConstruction to prove Snell’s Law\n\n\nConstrained minimization problem: Minimize $n_1 d_1 _1 + $",
    "crumbs": [
      "Year 1",
      "Learning Optics"
    ]
  },
  {
    "objectID": "optics.html#citations",
    "href": "optics.html#citations",
    "title": "Learning Optics",
    "section": "Citations",
    "text": "Citations\n[1] Saleh, B. E. A., & Teich, M. C. (2019). Fundamentals of photonics (3rd ed.). Wiley. [2] Peatross, Justin, and Michael Ware. Physics of Light and Optics. 2015 ed., January 31, 2025 revision, Department of Physics, Brigham Young University. optics.byu.edu.",
    "crumbs": [
      "Year 1",
      "Learning Optics"
    ]
  }
]