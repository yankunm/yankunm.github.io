[
  {
    "objectID": "simulation/wfov.html",
    "href": "simulation/wfov.html",
    "title": "Wide FOV Metasurface",
    "section": "",
    "text": "This is reproduction of the results in 1(b) using Diffraction Monitor. Parameters from the paper:\nP= 190nm h= 230nm D= [60, 135]nm \\lambda = 532nm\n\n\n\n\n# Import the necessary packages\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport tidy3d as td\nimport tidy3d.web as web\nimport scienceplots\n\n# Set logging level to ERROR to reduce output verbosity\ntd.config.logging_level = \"ERROR\"\n\n\n# 0 Define a FreqRange object with desired wavelengths\nlda0 = 0.532\nfreq0 = td.C_0 / lda0\nprint(\"%E\" % freq0)\n\n5.635197E+14\n\n\n\n# 1 Computational Domain Size\nh = 0.230  # Height of cylinder\nspc = 1\nLz = spc + h + h + spc\n\nPx = Py = P = 0.190 # periodicity\nsim_size = [Px, Py, Lz]\n\n\n# 2 Grid Resolution\ndl = P / 32\nhorizontal_grid = td.UniformGrid(dl=dl)\nvertical_grid = td.AutoGrid(min_steps_per_wvl=32)\ngrid_spec=td.GridSpec(\n    grid_x=horizontal_grid,\n    grid_y=horizontal_grid,\n    grid_z=vertical_grid,\n)\n\n\nsap = td.material_library['Sapphire']['Horiba']\nsi = td.material_library['cSi']['Green2008']\n\nsubstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,-Lz/2),\n        size=(td.inf,td.inf,2 * (spc+h))\n    ),\n    medium=sap,\n    name='substrate'\n)\n\n\nsource = td.PlaneWave(\n    source_time=td.GaussianPulse(freq0=freq0, fwidth=20e12),\n    size=(td.inf, td.inf,0),\n    center=(0, 0, Lz/2 - spc + 0.5 * lda0),\n    direction=\"-\",\n    pol_angle=0\n)\n\n\nmonitor = td.DiffractionMonitor(\n    center=(0, 0, -Lz/2 + spc - 0.5 * lda0),\n    size=(td.inf,td.inf,0),\n    freqs=[freq0],\n    name='diffraction_monitor',\n    normal_dir='-', # away from structure\n)\n\n\nbc = td.BoundarySpec(\n    x=td.Boundary.periodic(), \n    y=td.Boundary.periodic(), \n    z=td.Boundary.pml()\n)\n\n\nD = np.arange(0.060, 0.140, 0.005)\nprint(D)\nsims = {}\nrun_time = 50\n\ndef simulate(D):\n    for i, diameter in enumerate(D):\n        cylinder = td.Structure(\n            geometry=td.Cylinder(\n                center=[0, 0, h / 2], \n                radius=diameter/2, \n                length=h, \n            axis=2), \n            medium=si\n        )\n        \n        sim = td.Simulation(\n            size = sim_size,\n            grid_spec = grid_spec,\n            structures = [cylinder, substrate],\n            sources=[source],\n            monitors=[monitor],\n            run_time= run_time / freq0,\n            boundary_spec=bc\n        )\n\n        sims[f\"d{i}\"] = sim\n\n[0.06  0.065 0.07  0.075 0.08  0.085 0.09  0.095 0.1   0.105 0.11  0.115\n 0.12  0.125 0.13  0.135 0.14 ]\n\n\n\nsimulate(D)\nprint(sims.keys())\nsim_actual=sims['d7']\n# Always visualize simulation before running\nfig, (ax1,ax2,ax3) = plt.subplots(1, 3, figsize=(12, 6))\nax1.tick_params(axis='x', labelsize=7)\nax2.tick_params(axis='x', labelsize=7)\nsim_actual.plot(x=0, ax=ax1)\nsim_actual.plot_grid(x=0, ax=ax1)\nsim_actual.plot(y=0, ax=ax2)\nsim_actual.plot_grid(y=0, ax=ax2)\nsim_actual.plot(z=0.1, ax=ax3)\nsim_actual.plot_grid(z=0, ax=ax3)\nplt.show()\n\ndict_keys(['d0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'd10', 'd11', 'd12', 'd13', 'd14', 'd15', 'd16'])\n\n\n\n\n\n\n\n\n\n\nbatch = web.Batch(simulations=sims, verbose=True)\nbatch_data = batch.run(path_dir=\"data/wfov_01\")\n\n\n\n\n\n\n\n20:23:21 EDT Started working on Batch containing 17 tasks.                      \n\n\n\n20:23:33 EDT Maximum FlexCredit cost: 0.425 for the whole batch.                \n\n\n\n             Use 'Batch.real_cost()' to get the billed FlexCredit cost after the\n             Batch has completed.                                               \n\n\n\n\n\n\n20:23:42 EDT Batch complete.                                                    \n\n\n\n\n\n\n\n\n\n\n\n\n\ndD = []\nfor i in range(len(D)):\n    dD.append(batch_data[f\"d{i}\"][\"diffraction_monitor\"])\n\n\npower = np.array([dD[i].power[0][0] for i in range(len(dD))])\n\n\n# this uses scienceplots to make plots look better\nplt.style.use(['science', 'notebook', 'grid'])\n# plot transmission, compare to paper results, look similar\nfig, ax = plt.subplots(1, 1, figsize=(6, 4.5))\nplt.plot(D*1000, power, \"o-\", color=\"red\", ms=2, lw=0.5, label=\"T\")\nplt.xlabel(r\"Diameter ($nm$)\")\nplt.ylabel(\"Power\")\nplt.ylim(0, 1)\nplt.xlim(60, 140)\nplt.legend()\nplt.savefig(\"power_wfov\", dpi=300)\nplt.show()",
    "crumbs": [
      "Simulation",
      "Wide FOV Metasurface"
    ]
  },
  {
    "objectID": "simulation/matplotlib.html",
    "href": "simulation/matplotlib.html",
    "title": "Matplotlib",
    "section": "",
    "text": "Note: plt.show() must be called if you want to see the plot in a script. In a notebook, it is optional.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scienceplots # professional paper plots\n\n\n# this uses scienceplots to make plots look better\nplt.style.use(['science', 'notebook', 'grid'])\n\n\nBasics\n\nx = np.linspace(0, 15, 30)\ny = np.sin(x) + 0.1 * np.random.randn(len(x)) # sine plus noise\n\n\nplt.plot(x, y)\n\n\n\n\n\n\n\n\n\n# change the way the line was drawn\n# plt.plot(x, y, '--') # dashed line\n# plt.plot(x, y, 'o--', label='data with noise') # add a legend label\nplt.plot(x, y, 'o--', color='blue', lw=1, ms=2) # changing color, line width (lw), marker/dot size (ms)\n\n\n\n\n\n\n\n\n\n# change figure size\nplt.figure(figsize=(8, 3)) # 8 in x and 3 in y (aspect ratio)\nplt.plot(x, y, 'o--', color='red', lw=1, ms=2)\n\n\n\n\n\n\n\n\n\n# axis labels\nplt.figure(figsize=(8, 3)) # 8 in x and 3 in y (aspect ratio)\nplt.plot(x, y, 'o--', color='red', lw=1, ms=2)\nplt.xlabel(\"Time [sec]\")\nplt.ylabel(\"Voltage [V]\")\n\nText(0, 0.5, 'Voltage (V)')\n\n\n\n\n\n\n\n\n\n\nx2 = np.linspace(0, 15, 100)\ny2 = np.sin(x2)\n\n# if you have multiple things in the plot, you can add a legend\nplt.figure(figsize=(8, 3)) # 8 in x and 3 in y (aspect ratio)\nplt.plot(x, y, 'o', color='red', lw=1, ms=2, label=\"component 1\")\nplt.plot(x2, y2, '-', color='blue', lw=0.5, label=\"original\")\nplt.xlabel(\"Time [sec]\")\nplt.ylabel(\"Voltage [V]\")\nplt.legend(loc='upper right', fontsize=10) # loc= 'upper right', 'lower left', etc. \n\n\n\n\n\n\n\n\n\n# what if you need more space? limits\n# if you have multiple things in the plot, you can add a legend\nplt.figure(figsize=(8, 3)) # 8 in x and 3 in y (aspect ratio)\nplt.plot(x, y, 'o', color='red', lw=1, ms=2, label=\"component 1\")\nplt.plot(x2, y2, '-', color='blue', lw=0.5, label=\"original\")\nplt.xlabel(\"Time [sec]\")\nplt.ylabel(\"Voltage [V]\")\nplt.ylim(top=2) # change y limit, bottom=..., left=..., right=...\nplt.legend(loc='upper right', fontsize=10, ncol=2) # make legend two columns so it doesn't take too much space\n\n\n\n\n\n\n\n\n\n# changing ticks\nplt.figure(figsize=(8, 3)) # 8 in x and 3 in y (aspect ratio)\nplt.plot(x, y, 'o', color='red', lw=1, ms=2, label=\"component 1\")\nplt.plot(x2, y2, '-', color='blue', lw=0.5, label=\"original\")\nplt.xlabel(\"Time [sec]\")\nplt.ylabel(\"Voltage [V]\")\nplt.ylim(top=2) # change y limit, bottom=..., left=..., right=...\nplt.legend(loc='upper right', fontsize=10, ncol=2) # make legend two columns so it doesn't take too much space\nplt.tick_params(axis='both', labelsize=10) # change tick label size to 10\n# axis can be 'x', 'y', or 'both'\n\n\n\n\n\n\n\n\n\n\nHistograms\n\nres = np.random.randn(1000)*0.2 + 0.4\nplt.hist(res)\n\n(array([  3.,  10.,  55., 158., 272., 249., 159.,  76.,  15.,   3.]),\n array([-0.27877989, -0.14374564, -0.0087114 ,  0.12632285,  0.2613571 ,\n         0.39639135,  0.5314256 ,  0.66645984,  0.80149409,  0.93652834,\n         1.07156259]),\n &lt;BarContainer object of 10 artists&gt;)\n\n\n\n\n\n\n\n\n\n\n# settings bins\nplt.hist(res, bins=30) # more bins\nplt.show()\n\n\n\n\n\n\n\n\n\n# Normalize the histogram such that area = 1\nplt.hist(res, bins=30, density=True)\nplt.show()\n\n\n\n\n\n\n\n\n\n# different styles of bins (useful for multiple histograms)\n# the different types are 'bar', 'barstacked', 'step', 'stepfilled'\nres2 = np.random.randn(1000)*0.2 + 0.4\n\nplt.figure(figsize=(6,4))\nplt.hist(res, bins=30, density=True, histtype='bar', alpha=0.5) # alpha is transparency\nplt.hist(res2, bins=30, density=True, histtype='step')\nplt.show()\n\n\n\n\n\n\n\n\n\n\nAdvanced Plotting\n\nMultiple subplots on 1 figure\nadding text\nanimations\n\n\n# Create an array of plots\nfig, ax = plt.subplots(1, 1, figsize=(12, 4)) # 1 row by 1 column of plots\nax.plot(x, y, 'o--', color='red', lw=1, ms=2)\n\n\n\n\n\n\n\n\n\n# A small change to labeling\nfig, ax = plt.subplots(1, 1, figsize=(12, 4)) # 1 row by 1 column of plots\nax.plot(x, y, 'o--', color='red', lw=1, ms=2)\nax.set_xlabel(\"Time [sec]\")\nax.set_ylabel(\"Voltage [V]\")\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, axes = plt.subplots(3, 2, figsize=(12, 12)) # 2 rows by 2 columns of plots\naxes\n\narray([[&lt;Axes: &gt;, &lt;Axes: &gt;],\n       [&lt;Axes: &gt;, &lt;Axes: &gt;],\n       [&lt;Axes: &gt;, &lt;Axes: &gt;]], dtype=object)\n\n\n\n\n\n\n\n\n\n\nfig, axes = plt.subplots(3, 2, figsize=(12, 12)) # 2 rows by 2 columns of plots\nax = axes[0][0]\n# do everything you need to do to the first axis\nax = axes[1][1] # row 1 column 1\nax.hist(res, bins=30, density=True)\nax.set_xlabel(\"Value\")\nax.set_ylabel(\"Probability\")  \nax.set_title(\"Histogram of Random Values\")\nplt.show()\n\n\n\n\n\n\n\n\n\n# adding text/labeling inside the plot\nfig, ax = plt.subplots(1, 1, figsize=(5, 3)) # 1 row by 1 column of plots\nax.text(0.1, 0.1, \"This is some text\", fontsize=10, color='red', alpha=0.5) # this takes literal values\nax.plot(x, y, 'o--', color='red', lw=1, ms=2)\nax.set_xlabel(\"Time [sec]\")\nax.set_ylabel(\"Voltage [V]\")       \nplt.show()\n\n\n\n\n\n\n\n\n\n# if you want dimensionless text labeling\nfig, ax = plt.subplots(1, 1, figsize=(5, 3)) # 1 row by 1 column of plots\nax.text(0.1, 0.1, \"This is some text\", transform=ax.transAxes) # this sets (0,0) to bottom left and (1,1) to top right for the text\nax.plot(x, y, 'o--', color='red', lw=1, ms=2)\nax.set_xlabel(\"Time [sec]\")\nax.set_ylabel(\"Voltage [V]\")       \nplt.show()\n\n\n\n\n\n\n\n\n\n\nResources\n\nMr. P Solver Youtube Channel\nInstall SciencePlots",
    "crumbs": [
      "Python",
      "Matplotlib"
    ]
  },
  {
    "objectID": "simulation/matplotlib.slides.html#basics",
    "href": "simulation/matplotlib.slides.html#basics",
    "title": "Matplotlib",
    "section": "Basics",
    "text": "Basics\n\nx = np.linspace(0, 15, 30)\ny = np.sin(x) + 0.1 * np.random.randn(len(x)) # sine plus noise\n\n\nplt.plot(x, y)\n\n\n\n\n\n\n\n\n\n# change the way the line was drawn\n# plt.plot(x, y, '--') # dashed line\n# plt.plot(x, y, 'o--', label='data with noise') # add a legend label\nplt.plot(x, y, 'o--', color='blue', lw=1, ms=2) # changing color, line width (lw), marker/dot size (ms)\n\n\n\n\n\n\n\n\n\n# change figure size\nplt.figure(figsize=(8, 3)) # 8 in x and 3 in y (aspect ratio)\nplt.plot(x, y, 'o--', color='red', lw=1, ms=2)\n\n\n\n\n\n\n\n\n\n# axis labels\nplt.figure(figsize=(8, 3)) # 8 in x and 3 in y (aspect ratio)\nplt.plot(x, y, 'o--', color='red', lw=1, ms=2)\nplt.xlabel(\"Time [sec]\")\nplt.ylabel(\"Voltage [V]\")\n\nText(0, 0.5, 'Voltage (V)')\n\n\n\n\n\n\n\n\n\n\nx2 = np.linspace(0, 15, 100)\ny2 = np.sin(x2)\n\n# if you have multiple things in the plot, you can add a legend\nplt.figure(figsize=(8, 3)) # 8 in x and 3 in y (aspect ratio)\nplt.plot(x, y, 'o', color='red', lw=1, ms=2, label=\"component 1\")\nplt.plot(x2, y2, '-', color='blue', lw=0.5, label=\"original\")\nplt.xlabel(\"Time [sec]\")\nplt.ylabel(\"Voltage [V]\")\nplt.legend(loc='upper right', fontsize=10) # loc= 'upper right', 'lower left', etc. \n\n\n\n\n\n\n\n\n\n# what if you need more space? limits\n# if you have multiple things in the plot, you can add a legend\nplt.figure(figsize=(8, 3)) # 8 in x and 3 in y (aspect ratio)\nplt.plot(x, y, 'o', color='red', lw=1, ms=2, label=\"component 1\")\nplt.plot(x2, y2, '-', color='blue', lw=0.5, label=\"original\")\nplt.xlabel(\"Time [sec]\")\nplt.ylabel(\"Voltage [V]\")\nplt.ylim(top=2) # change y limit, bottom=..., left=..., right=...\nplt.legend(loc='upper right', fontsize=10, ncol=2) # make legend two columns so it doesn't take too much space\n\n\n\n\n\n\n\n\n\n# changing ticks\nplt.figure(figsize=(8, 3)) # 8 in x and 3 in y (aspect ratio)\nplt.plot(x, y, 'o', color='red', lw=1, ms=2, label=\"component 1\")\nplt.plot(x2, y2, '-', color='blue', lw=0.5, label=\"original\")\nplt.xlabel(\"Time [sec]\")\nplt.ylabel(\"Voltage [V]\")\nplt.ylim(top=2) # change y limit, bottom=..., left=..., right=...\nplt.legend(loc='upper right', fontsize=10, ncol=2) # make legend two columns so it doesn't take too much space\nplt.tick_params(axis='both', labelsize=10) # change tick label size to 10\n# axis can be 'x', 'y', or 'both'"
  },
  {
    "objectID": "simulation/matplotlib.slides.html#histograms",
    "href": "simulation/matplotlib.slides.html#histograms",
    "title": "Matplotlib",
    "section": "Histograms",
    "text": "Histograms\n\nres = np.random.randn(1000)*0.2 + 0.4\nplt.hist(res)\n\n(array([  3.,  10.,  55., 158., 272., 249., 159.,  76.,  15.,   3.]),\n array([-0.27877989, -0.14374564, -0.0087114 ,  0.12632285,  0.2613571 ,\n         0.39639135,  0.5314256 ,  0.66645984,  0.80149409,  0.93652834,\n         1.07156259]),\n &lt;BarContainer object of 10 artists&gt;)\n\n\n\n\n\n\n\n\n\n\n# settings bins\nplt.hist(res, bins=30) # more bins\nplt.show()\n\n\n\n\n\n\n\n\n\n# Normalize the histogram such that area = 1\nplt.hist(res, bins=30, density=True)\nplt.show()\n\n\n\n\n\n\n\n\n\n# different styles of bins (useful for multiple histograms)\n# the different types are 'bar', 'barstacked', 'step', 'stepfilled'\nres2 = np.random.randn(1000)*0.2 + 0.4\n\nplt.figure(figsize=(6,4))\nplt.hist(res, bins=30, density=True, histtype='bar', alpha=0.5) # alpha is transparency\nplt.hist(res2, bins=30, density=True, histtype='step')\nplt.show()"
  },
  {
    "objectID": "simulation/matplotlib.slides.html#advanced-plotting",
    "href": "simulation/matplotlib.slides.html#advanced-plotting",
    "title": "Matplotlib",
    "section": "Advanced Plotting",
    "text": "Advanced Plotting\n\nMultiple subplots on 1 figure\nadding text\nanimations\n\n\n# Create an array of plots\nfig, ax = plt.subplots(1, 1, figsize=(12, 4)) # 1 row by 1 column of plots\nax.plot(x, y, 'o--', color='red', lw=1, ms=2)\n\n\n\n\n\n\n\n\n\n# A small change to labeling\nfig, ax = plt.subplots(1, 1, figsize=(12, 4)) # 1 row by 1 column of plots\nax.plot(x, y, 'o--', color='red', lw=1, ms=2)\nax.set_xlabel(\"Time [sec]\")\nax.set_ylabel(\"Voltage [V]\")\nplt.show()\n\n\n\n\n\n\n\n\n\nfig, axes = plt.subplots(3, 2, figsize=(12, 12)) # 2 rows by 2 columns of plots\naxes\n\narray([[&lt;Axes: &gt;, &lt;Axes: &gt;],\n       [&lt;Axes: &gt;, &lt;Axes: &gt;],\n       [&lt;Axes: &gt;, &lt;Axes: &gt;]], dtype=object)\n\n\n\n\n\n\n\n\n\n\nfig, axes = plt.subplots(3, 2, figsize=(12, 12)) # 2 rows by 2 columns of plots\nax = axes[0][0]\n# do everything you need to do to the first axis\nax = axes[1][1] # row 1 column 1\nax.hist(res, bins=30, density=True)\nax.set_xlabel(\"Value\")\nax.set_ylabel(\"Probability\")  \nax.set_title(\"Histogram of Random Values\")\nplt.show()\n\n\n\n\n\n\n\n\n\n# adding text/labeling inside the plot\nfig, ax = plt.subplots(1, 1, figsize=(5, 3)) # 1 row by 1 column of plots\nax.text(0.1, 0.1, \"This is some text\", fontsize=10, color='red', alpha=0.5) # this takes literal values\nax.plot(x, y, 'o--', color='red', lw=1, ms=2)\nax.set_xlabel(\"Time [sec]\")\nax.set_ylabel(\"Voltage [V]\")       \nplt.show()\n\n\n\n\n\n\n\n\n\n# if you want dimensionless text labeling\nfig, ax = plt.subplots(1, 1, figsize=(5, 3)) # 1 row by 1 column of plots\nax.text(0.1, 0.1, \"This is some text\", transform=ax.transAxes) # this sets (0,0) to bottom left and (1,1) to top right for the text\nax.plot(x, y, 'o--', color='red', lw=1, ms=2)\nax.set_xlabel(\"Time [sec]\")\nax.set_ylabel(\"Voltage [V]\")       \nplt.show()"
  },
  {
    "objectID": "simulation/matplotlib.slides.html#resources",
    "href": "simulation/matplotlib.slides.html#resources",
    "title": "Matplotlib",
    "section": "Resources",
    "text": "Resources\n\nMr. P Solver Youtube Channel\nInstall SciencePlots"
  },
  {
    "objectID": "simulation/geom_phase.html",
    "href": "simulation/geom_phase.html",
    "title": "Ultra narrowband Metasurface",
    "section": "",
    "text": "In this simulation of Paper Link, I did 1200-1600nm parameter sweep, and linear polarization. Finding the transmittance of this structure.\n\n\n\nFigure from paper\n\n\n\n\n\n\n\n\n\n\nPreconditions\n\n# Import the necessary packages\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport tidy3d as td\nimport tidy3d.web as web\nfrom tidy3d import material_library\nimport scienceplots\n\ntd.config.logging_level = \"ERROR\"\n\n\n# 0 Define a FreqRange object with desired wavelengths\nfr = td.FreqRange.from_wvl_interval(wvl_min=1.2, wvl_max=1.6)\nN = 501 # num_points\nfwidth = fr.fmax - fr.fmin\nfreq0 = fr.freq0\nlda0 = td.C_0 / fr.freq0\n\n\n# 1 Computational Domain Size\nh = 0.210  # Height of cylinder\nspc = 8\nsh = 3  # height of the SiO2\nLz = spc + h + spc + h\n\nPx = Py = P = 0.750 # periodicity\nsim_size = [Px, Py, Lz]\n\n\n\n# 2 Grid Resolution\ndl = P / 32\nhorizontal_grid = td.UniformGrid(dl=dl)\nvertical_grid = td.AutoGrid(min_steps_per_wvl=32)\ngrid_spec=td.GridSpec(\n    grid_x=horizontal_grid,\n    grid_y=horizontal_grid,\n    grid_z=vertical_grid,\n)\n\n\n# 3 Structures and Materials\nR = 0.235  # radius of the cylinder\nr = 0.030  # radius of the inner hole\np = 0.080  # distance between hole to center of circle\ntheta = np.deg2rad(90) # angle between x-axis and p vector\n\nSi = material_library['cSi']['Green2008']\nSiO2 = material_library['SiO2']['Horiba']\n\nouter_cylinder = td.Cylinder(\n    center=[0, 0, h / 2], \n    radius=R, \n    length=h, \n    axis=2\n)\n\ninner_cylinder = td.Cylinder(\n    center=[p*np.cos(theta), -p*np.sin(theta), h / 2], \n    radius=r, \n    length=h, \n    axis=2\n)\n\ncylinder = td.ClipOperation(\n    operation=\"difference\",\n    geometry_a=outer_cylinder,\n    geometry_b=inner_cylinder\n)\n\natom = td.Structure(\n    geometry=cylinder, \n    medium=Si,\n    name=\"metaatom\"\n)\n\ndioxide = td.Structure(\n    geometry=td.Box(\n        center=[0,0,-sh/2],\n        size=(td.inf,td.inf, sh)\n    ),\n    medium=SiO2, \n    name=\"silicon dioxide\"\n)\n\nsubstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,-Lz/2),\n        size=(td.inf,td.inf,2 * (spc - (sh - h)))\n    ),\n    medium=Si,\n    name='substrate'\n)\n\n\n\nsource = td.PlaneWave(\n    source_time=td.GaussianPulse(freq0=fr.freq0, fwidth=fwidth),\n    size=(td.inf, td.inf, 0),\n    center=(0, 0, -Lz/2 + spc - (sh - h) - 0.5 * lda0),\n    direction=\"+\",\n    pol_angle=0,\n)\n\n\nmonitor = td.FluxMonitor(\n    center=(0, 0, Lz/2 - spc + 1.5 * lda0),\n    size=(td.inf, td.inf, 0),\n    freqs=fr.freqs(N),\n    name=\"flux_monitor\"\n)\n\n\n\nbandwidth = fr.fmax - fr.fmin\nrun_time = 500 / bandwidth # run_time for the transmittance simulation\n\n\nbc = td.BoundarySpec(\n    x=td.Boundary.periodic(), \n    y=td.Boundary.periodic(), \n    z=td.Boundary.pml()\n)\n\n\n\nSimulation\n\nsim_empty = td.Simulation(\n    size=sim_size,\n    grid_spec=grid_spec,\n    structures=[substrate, dioxide],\n    sources=[source],\n    monitors=[monitor],\n    run_time=run_time,\n    boundary_spec=bc\n)\n\nsim_actual = td.Simulation(\n    size=sim_size,\n    grid_spec=grid_spec,\n    structures=[substrate, dioxide, atom],\n    sources=[source],\n    monitors=[monitor],\n    run_time=run_time,\n    boundary_spec=bc\n)\n\n\nsims = {\n    \"actual\": sim_actual,\n    \"norm\": sim_empty\n}\n\n\nsims[\"actual\"].plot_3d()\n\n\n    \n    \n    \n\n\n\n# Always visualize simulation before running\nfig, (ax1,ax2,ax3) = plt.subplots(1, 3, tight_layout=True, figsize=(12, 6))\nax1.tick_params(axis='x', labelsize=7)\nax2.tick_params(axis='x', labelsize=7)\nsims[\"actual\"].plot(x=0, ax=ax1)\n# sim_actual.plot_grid(x=0, ax=ax1)\nsims[\"actual\"].plot(y=0, ax=ax2)\n# sim_actual.plot_grid(y=0, ax=ax2)\nsims[\"actual\"].plot(z=0, ax=ax3)\n# sim_actual.plot_grid(z=0, ax=ax3)\nplt.savefig(f'geomp_structure.png', dpi=300)\nplt.show()\n\n\n\n\n\n\n\n\n\nbatch = web.Batch(simulations=sims, verbose=True)\nbatch_data = batch.run(path_dir=\"data/geom_linear\")\n\n\n\n\n\n\n\n20:57:30 EDT Started working on Batch containing 2 tasks.                       \n\n\n\n20:57:31 EDT Maximum FlexCredit cost: 0.370 for the whole batch.                \n\n\n\n             Use 'Batch.real_cost()' to get the billed FlexCredit cost after the\n             Batch has completed.                                               \n\n\n\n\n\n\n20:57:32 EDT Batch complete.                                                    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPostprocess\n\nT_actual = batch_data[\"actual\"][\"flux_monitor\"].flux \nT_norm = batch_data[\"norm\"][\"flux_monitor\"].flux\n\n\n# this uses scienceplots to make plots look better\nplt.style.use(['science', 'notebook', 'grid'])\n# plot transmission, compare to paper results, look similar\nfig, ax = plt.subplots(1, 1, figsize=(6, 4.5))\nplt.plot(td.C_0 / fr.freqs(N) * 1000, T_actual, \"r\", lw=1, label=\"T with Metaatom\")\nplt.plot(td.C_0 / fr.freqs(N) * 1000, T_norm, \"b\", lw=0.5, alpha=0.5, label=\"T w/o Metaatom\")\nplt.xlabel(r\"wavelength ($nm$)\")\nplt.ylabel(\"Transmittance\")\nplt.legend()\nplt.title(\"Transmittance vs Wavelength\")\nplt.savefig(\"power_geom\", dpi=300)\nplt.show()\n\n\n\n\n\n\n\n\n\n\nZooming in and doing Runtime Analysis\n\n# 0 Define a FreqRange object with desired wavelengths\nfr = td.FreqRange.from_wvl_interval(wvl_min=1.505, wvl_max=1.515)\nN = 701 # increased num_points\nfwidth = fr.fmax - fr.fmin\nfreq0 = fr.freq0\nlda0 = td.C_0 / fr.freq0\n\n\n\nsource = td.PlaneWave(\n    source_time=td.GaussianPulse(freq0=fr.freq0, fwidth=fwidth),\n    size=(td.inf, td.inf, 0),\n    center=(0, 0, -Lz/2 + spc - (sh - h) - 0.5 * lda0),\n    direction=\"+\",\n    pol_angle=0,\n)\n\nmonitor = td.FluxMonitor(\n    center=(0, 0, Lz/2 - spc + 1.5 * lda0),\n    size=(td.inf, td.inf, 0),\n    freqs=fr.freqs(N),\n    name=\"flux_monitor\"\n)\n\nbandwidth = fr.fmax - fr.fmin\n# run_time = 50 / bandwidth # run_time for the transmittance simulation\n\n\nbc = td.BoundarySpec(\n    x=td.Boundary.periodic(), \n    y=td.Boundary.periodic(), \n    z=td.Boundary.pml()\n)\n\n\n\n# Runtime Loop Assignment\nalphas = [10, 50, 100, 150, 200]\nrun_times = [x / bandwidth for x in alphas]\nsims = {}\n\nfor i, run_time in enumerate(run_times):\n    sim_actual = td.Simulation(\n        size=sim_size,\n        grid_spec=grid_spec,\n        structures=[substrate, dioxide, atom],\n        sources=[source],\n        monitors=[monitor],\n        run_time=run_time,\n        boundary_spec=bc\n    )\n\n    sims[f\"actual{i}\"] = sim_actual\n\n\nbatch = web.Batch(simulations=sims, verbose=True)\nbatch_data = batch.run(path_dir=\"data/geom_lin\")\n\n\n\n\n\n\n\n21:01:35 EDT Started working on Batch containing 5 tasks.                       \n\n\n\n21:01:40 EDT Maximum FlexCredit cost: 7.571 for the whole batch.                \n\n\n\n             Use 'Batch.real_cost()' to get the billed FlexCredit cost after the\n             Batch has completed.                                               \n\n\n\n\n\n\n21:01:43 EDT Batch complete.                                                    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Runtime Analysis Postprocess\nplt.style.use(['science', 'notebook', 'grid'])\n\nx = td.C_0 / fr.freqs(N) * 1000\nTs = []\nfor i in range(len(alphas)):\n    Ts.append(batch_data[f\"actual{i}\"][\"flux_monitor\"].flux)\n\n\nplt.figure(figsize=(10, 5))\nfor i, T in enumerate(Ts):\n    plt.plot(x, T, \"-\",lw=1, label=f\"dl={alphas[i] * 1000:.1f} sec\")\nplt.xlabel(r\"Wavelength [$nm$]\", fontsize=12)\nplt.ylabel(\"Power\", fontsize=12)\nplt.xlim(1505, 1515)\nplt.ylim(0, 1.1)\nplt.legend(fontsize=12)\nplt.tick_params(axis='both', labelsize=10) # change tick label size to 10\nplt.title(\"Transmission Spectra with Different Runtimes\", fontsize=14)\nplt.savefig(\"runtimes.png\", dpi=300)\nplt.show()",
    "crumbs": [
      "Simulation",
      "Ultra narrowband Metasurface"
    ]
  },
  {
    "objectID": "simulation/geom_phase.slides.html#preconditions",
    "href": "simulation/geom_phase.slides.html#preconditions",
    "title": "Ultra narrowband Metasurface",
    "section": "Preconditions",
    "text": "Preconditions\n\n# Import the necessary packages\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport tidy3d as td\nimport tidy3d.web as web\nfrom tidy3d import material_library\nimport scienceplots\n\ntd.config.logging_level = \"ERROR\"\n\n\n# 0 Define a FreqRange object with desired wavelengths\nfr = td.FreqRange.from_wvl_interval(wvl_min=1.2, wvl_max=1.6)\nN = 501 # num_points\nfwidth = fr.fmax - fr.fmin\nfreq0 = fr.freq0\nlda0 = td.C_0 / fr.freq0\n\n\n# 1 Computational Domain Size\nh = 0.210  # Height of cylinder\nspc = 8\nsh = 3  # height of the SiO2\nLz = spc + h + spc + h\n\nPx = Py = P = 0.750 # periodicity\nsim_size = [Px, Py, Lz]"
  },
  {
    "objectID": "simulation/geom_phase.slides.html#simulation",
    "href": "simulation/geom_phase.slides.html#simulation",
    "title": "Ultra narrowband Metasurface",
    "section": "Simulation",
    "text": "Simulation\n\nsim_empty = td.Simulation(\n    size=sim_size,\n    grid_spec=grid_spec,\n    structures=[substrate, dioxide],\n    sources=[source],\n    monitors=[monitor],\n    run_time=run_time,\n    boundary_spec=bc\n)\n\nsim_actual = td.Simulation(\n    size=sim_size,\n    grid_spec=grid_spec,\n    structures=[substrate, dioxide, atom],\n    sources=[source],\n    monitors=[monitor],\n    run_time=run_time,\n    boundary_spec=bc\n)\n\n\nsims = {\n    \"actual\": sim_actual,\n    \"norm\": sim_empty\n}\n\n\nsims[\"actual\"].plot_3d()\n\n\n    \n    \n    \n\n\n\n# Always visualize simulation before running\nfig, (ax1,ax2,ax3) = plt.subplots(1, 3, tight_layout=True, figsize=(12, 6))\nax1.tick_params(axis='x', labelsize=7)\nax2.tick_params(axis='x', labelsize=7)\nsims[\"actual\"].plot(x=0, ax=ax1)\n# sim_actual.plot_grid(x=0, ax=ax1)\nsims[\"actual\"].plot(y=0, ax=ax2)\n# sim_actual.plot_grid(y=0, ax=ax2)\nsims[\"actual\"].plot(z=0, ax=ax3)\n# sim_actual.plot_grid(z=0, ax=ax3)\nplt.savefig(f'geomp_structure.png', dpi=300)\nplt.show()\n\n\n\nbatch = web.Batch(simulations=sims, verbose=True)\nbatch_data = batch.run(path_dir=\"data/geom_linear\")\n\n\n\n\n\n\n\n20:57:30 EDT Started working on Batch containing 2 tasks.                       \n\n\n\n20:57:31 EDT Maximum FlexCredit cost: 0.370 for the whole batch.                \n\n\n\n             Use 'Batch.real_cost()' to get the billed FlexCredit cost after the\n             Batch has completed.                                               \n\n\n\n\n\n\n20:57:32 EDT Batch complete."
  },
  {
    "objectID": "simulation/geom_phase.slides.html#postprocess",
    "href": "simulation/geom_phase.slides.html#postprocess",
    "title": "Ultra narrowband Metasurface",
    "section": "Postprocess",
    "text": "Postprocess\n\nT_actual = batch_data[\"actual\"][\"flux_monitor\"].flux \nT_norm = batch_data[\"norm\"][\"flux_monitor\"].flux\n\n\n# this uses scienceplots to make plots look better\nplt.style.use(['science', 'notebook', 'grid'])\n# plot transmission, compare to paper results, look similar\nfig, ax = plt.subplots(1, 1, figsize=(6, 4.5))\nplt.plot(td.C_0 / fr.freqs(N) * 1000, T_actual, \"r\", lw=1, label=\"T with Metaatom\")\nplt.plot(td.C_0 / fr.freqs(N) * 1000, T_norm, \"b\", lw=0.5, alpha=0.5, label=\"T w/o Metaatom\")\nplt.xlabel(r\"wavelength ($nm$)\")\nplt.ylabel(\"Transmittance\")\nplt.legend()\nplt.title(\"Transmittance vs Wavelength\")\nplt.savefig(\"power_geom\", dpi=300)\nplt.show()"
  },
  {
    "objectID": "simulation/geom_phase.slides.html#zooming-in-and-doing-runtime-analysis",
    "href": "simulation/geom_phase.slides.html#zooming-in-and-doing-runtime-analysis",
    "title": "Ultra narrowband Metasurface",
    "section": "Zooming in and doing Runtime Analysis",
    "text": "Zooming in and doing Runtime Analysis\n\n# 0 Define a FreqRange object with desired wavelengths\nfr = td.FreqRange.from_wvl_interval(wvl_min=1.505, wvl_max=1.515)\nN = 701 # increased num_points\nfwidth = fr.fmax - fr.fmin\nfreq0 = fr.freq0\nlda0 = td.C_0 / fr.freq0"
  },
  {
    "objectID": "experiment.html",
    "href": "experiment.html",
    "title": "Yankun (Alex) Meng",
    "section": "",
    "text": "import tidy3d as td\nimport numpy as np\nimport matplotlib.pyplot as plt \nimport tidy3d.web as web\n\n\nweb.test()\n\n18:03:04 EDT Authentication configured successfully!"
  },
  {
    "objectID": "simulation/numpy.html",
    "href": "simulation/numpy.html",
    "title": "Numpy",
    "section": "",
    "text": "NumPy is a package for dealing with arrays that’s very fast and efficient.\nCreating array:\narr1 = np.array([3, 5, 7, 3]) # convert list to array\narr2 = np.zeros(10) # array with 10 zeroes\narr3 = np.ones(10) # array with 10 ones\narrR = np.random.random(10) # sample 10 numbers from uniform distribution\narrG = np.random.randn(10) # sample 10 numbers from normal distribution\n\n\n\nlinspace - values equally spaced apart given the number of values\narr = np.linspace(0, 10, 100) # from 0 to 10, 100 values\narrange - values equally spaced apart given the spacing\narr = np.arrange(0, 10, 0.02) # from 0 to 10, spacing of 0.02",
    "crumbs": [
      "Python",
      "Numpy"
    ]
  },
  {
    "objectID": "simulation/numpy.html#introduction-and-basics",
    "href": "simulation/numpy.html#introduction-and-basics",
    "title": "Numpy",
    "section": "",
    "text": "NumPy is a package for dealing with arrays that’s very fast and efficient.\nCreating array:\narr1 = np.array([3, 5, 7, 3]) # convert list to array\narr2 = np.zeros(10) # array with 10 zeroes\narr3 = np.ones(10) # array with 10 ones\narrR = np.random.random(10) # sample 10 numbers from uniform distribution\narrG = np.random.randn(10) # sample 10 numbers from normal distribution\n\n\n\nlinspace - values equally spaced apart given the number of values\narr = np.linspace(0, 10, 100) # from 0 to 10, 100 values\narrange - values equally spaced apart given the spacing\narr = np.arrange(0, 10, 0.02) # from 0 to 10, spacing of 0.02",
    "crumbs": [
      "Python",
      "Numpy"
    ]
  },
  {
    "objectID": "simulation/numpy.html#array-manipulation",
    "href": "simulation/numpy.html#array-manipulation",
    "title": "Numpy",
    "section": "Array Manipulation",
    "text": "Array Manipulation\n\nCommon Array Operation\nElement-wise operation\narr + 2     # addition\narr - 5     # subtraction\n2*arr       # multiplication\n1/arr       # division\narr % 5     # Modulus\nLet’s try to do the same element-wise operation but using functions:\ndef f(x):\n    return x**2 * np.sin(x) / np.exp(-x)\n\nx = np.linspace(0, 10, 100)\ny = f(x) # Element-wise application of f\n\n\nCommon Plotting\nMost basic Plotting\nx = np.linspace(0, 1, 100)  # x-axis definition\ny = x**2                    # element-wise x^2\nplt.plot(x, x**2)           # plot(x, y)\nplt.show()                  # show the output\nHistogram\nplt.hist(arr) # plotting the array as histogram\n\n\nIndexing and Slicing\nNormal Indexing\narr = np.array([2, 4, 6, 8, 10])\narr[2]   # return 6\narr[2:]  # return 6, 8, 10 (including index 2)\narr[:-2] # return 2, 4, 6 (exluding index -2)\narr[1:2] # return 4\nBoolean Indexing\narr &gt; 5 # return a boolean array with true or false as elemenets\narr[arr&gt;5] # filtering --&gt;  return the elements that are true\nUsing Boolean Indexing to filter data\nnames = np.array(['Jim', 'Luke', 'Josh', 'Pete'])\nfirst_letter_j = np.vectorize(lambda s: s[0])(names) == 'J'\nprint(names[first_letter_j]) # gets the names that have first letter as J\nNow what is this doing?\n\n\nWhat is that doing?\nfirst_letter_j = np.vectorize(lambda s: s[0])(names) == 'J'\nLambda Function\nf = lambda s: s[0]\nThis is a function that says give me a string and I’ll give you the first character of the string. Note that String is not an array in python, but it supports the same indexing operations as arrays.\nWhat is np.vectorize?\nIt creates a for-loop, applies the function func to every element in the array arr, and return the result as an array.\nnp.vectorize(func)(arr) # this is an array",
    "crumbs": [
      "Python",
      "Numpy"
    ]
  },
  {
    "objectID": "simulation/numpy.html#calculus-statistical-functions",
    "href": "simulation/numpy.html#calculus-statistical-functions",
    "title": "Numpy",
    "section": "Calculus / Statistical Functions",
    "text": "Calculus / Statistical Functions\n\nCommon Statistics Functions\narr = 2*np.random.randn(10000) + 10 # 2 times std dev with a shift of 10 to the right\\\nnp.mean(arr) # approx 10\nnp.std(arr) # approx 2\nnp.percentile(arr, 80) # 80% numbers less than this number\n\n\nIntegrals and Derivatives\nx = np.linspace(1, 10, 100)\ny = 1/x**2 + np.sin(x)\nplt.plot(x, y)\nDerivatives\ndydx = np.gradient(y, x)\nIntegrals\nnp.cumsum([1, 2, 3, 4]) # return [1,3,6,10]\ny_int = np.cumsum(y) * (x[1] - x[0]) # int y dx\n\n\nResources Used\n\n[1] NumPy Tutorial\n[2] 100 numpy practice problems",
    "crumbs": [
      "Python",
      "Numpy"
    ]
  },
  {
    "objectID": "simulation/numpy.slides.html#what-is-numpy",
    "href": "simulation/numpy.slides.html#what-is-numpy",
    "title": "Numpy",
    "section": "What is NumPy?",
    "text": "What is NumPy?\nNumPy is a package for dealing with arrays that’s very fast and efficient.\nCreating array:\narr1 = np.array([3, 5, 7, 3]) # convert list to array\narr2 = np.zeros(10) # array with 10 zeroes\narr3 = np.ones(10) # array with 10 ones\narrR = np.random.random(10) # sample 10 numbers from uniform distribution\narrG = np.random.randn(10) # sample 10 numbers from normal distribution"
  },
  {
    "objectID": "simulation/numpy.slides.html#two-most-common-functions",
    "href": "simulation/numpy.slides.html#two-most-common-functions",
    "title": "Numpy",
    "section": "Two most common functions",
    "text": "Two most common functions\nlinspace - values equally spaced apart given the number of values\narr = np.linspace(0, 10, 100) # from 0 to 10, 100 values\narrange - values equally spaced apart given the spacing\narr = np.arrange(0, 10, 0.02) # from 0 to 10, spacing of 0.02"
  },
  {
    "objectID": "simulation/numpy.slides.html#common-array-operation",
    "href": "simulation/numpy.slides.html#common-array-operation",
    "title": "Numpy",
    "section": "Common Array Operation",
    "text": "Common Array Operation\nElement-wise operation\narr + 2     # addition\narr - 5     # subtraction\n2*arr       # multiplication\n1/arr       # division\narr % 5     # Modulus\nLet’s try to do the same element-wise operation but using functions:\ndef f(x):\n    return x**2 * np.sin(x) / np.exp(-x)\n\nx = np.linspace(0, 10, 100)\ny = f(x) # Element-wise application of f"
  },
  {
    "objectID": "simulation/numpy.slides.html#common-plotting",
    "href": "simulation/numpy.slides.html#common-plotting",
    "title": "Numpy",
    "section": "Common Plotting",
    "text": "Common Plotting\nMost basic Plotting\nx = np.linspace(0, 1, 100)  # x-axis definition\ny = x**2                    # element-wise x^2\nplt.plot(x, x**2)           # plot(x, y)\nplt.show()                  # show the output\nHistogram\nplt.hist(arr) # plotting the array as histogram"
  },
  {
    "objectID": "simulation/numpy.slides.html#indexing-and-slicing",
    "href": "simulation/numpy.slides.html#indexing-and-slicing",
    "title": "Numpy",
    "section": "Indexing and Slicing",
    "text": "Indexing and Slicing\nNormal Indexing\narr = np.array([2, 4, 6, 8, 10])\narr[2]   # return 6\narr[2:]  # return 6, 8, 10 (including index 2)\narr[:-2] # return 2, 4, 6 (exluding index -2)\narr[1:2] # return 4\nBoolean Indexing\narr &gt; 5 # return a boolean array with true or false as elemenets\narr[arr&gt;5] # filtering --&gt;  return the elements that are true\nUsing Boolean Indexing to filter data\nnames = np.array(['Jim', 'Luke', 'Josh', 'Pete'])\nfirst_letter_j = np.vectorize(lambda s: s[0])(names) == 'J'\nprint(names[first_letter_j]) # gets the names that have first letter as J\nNow what is this doing?"
  },
  {
    "objectID": "simulation/numpy.slides.html#what-is-that-doing",
    "href": "simulation/numpy.slides.html#what-is-that-doing",
    "title": "Numpy",
    "section": "What is that doing?",
    "text": "What is that doing?\nfirst_letter_j = np.vectorize(lambda s: s[0])(names) == 'J'\nLambda Function\nf = lambda s: s[0]\nThis is a function that says give me a string and I’ll give you the first character of the string. Note that String is not an array in python, but it supports the same indexing operations as arrays.\nWhat is np.vectorize?\nIt creates a for-loop, applies the function func to every element in the array arr, and return the result as an array.\nnp.vectorize(func)(arr) # this is an array"
  },
  {
    "objectID": "simulation/numpy.slides.html#common-statistics-functions",
    "href": "simulation/numpy.slides.html#common-statistics-functions",
    "title": "Numpy",
    "section": "Common Statistics Functions",
    "text": "Common Statistics Functions\narr = 2*np.random.randn(10000) + 10 # 2 times std dev with a shift of 10 to the right\\\nnp.mean(arr) # approx 10\nnp.std(arr) # approx 2\nnp.percentile(arr, 80) # 80% numbers less than this number"
  },
  {
    "objectID": "simulation/numpy.slides.html#integrals-and-derivatives",
    "href": "simulation/numpy.slides.html#integrals-and-derivatives",
    "title": "Numpy",
    "section": "Integrals and Derivatives",
    "text": "Integrals and Derivatives\nx = np.linspace(1, 10, 100)\ny = 1/x**2 + np.sin(x)\nplt.plot(x, y)\nDerivatives\ndydx = np.gradient(y, x)\nIntegrals\nnp.cumsum([1, 2, 3, 4]) # return [1,3,6,10]\ny_int = np.cumsum(y) * (x[1] - x[0]) # int y dx"
  },
  {
    "objectID": "simulation/numpy.slides.html#resources-used",
    "href": "simulation/numpy.slides.html#resources-used",
    "title": "Numpy",
    "section": "Resources Used",
    "text": "Resources Used\n\n[1] NumPy Tutorial\n[2] 100 numpy practice problems"
  },
  {
    "objectID": "log.html",
    "href": "log.html",
    "title": "Work Log",
    "section": "",
    "text": "Week 2 [9/1/2025-9/7/2025]\nTidy3D:\n\nMesh Study (P/2, P/4, P/8, P/16, P/32, …) on huygens metasurface and plot the transmission\nUnderstand how to calculate phase (Example)\nLearn how to use material library and define circular polarization (Example)\nRegenerate Figure 2B (Ultra narrowband geometric-phase resonant metasurfaces)\n\nNonlinear Optics:\nClasses so far:\n\nNonlinear susceptibility; anharmonic oscillator\nProperties of the nonlinear susceptibility; K.-K. relations 1.5—1.7\nWave equation in NLO; Coupled-wave equations for SFG 2.1—2.2\n\nSelf-Study:\n\nIIT Lectures 1-20\nBYU notebooks (implement 1, 2, 3, 4)\n\nAdvanced Optics:\nClasses so far:\n\nRay Optics, Graded Index Optics, Matrix Optics\nWave Optics, Paraxial Waves\nDiffraction/Transmission/Reflection\nGaussian Beams, ABCD matrices, etalons, thin films, cavities\nGuided wave optics, optical fibers, waveguides\n\nSelf-Study:\n\nFOP by Saleh 1, 2, 3, 6, 9, 11\n\n\n\nWeek 1 [8/25/2025-8/31/2025]\n\nTidy3D Huygen’s metasurface simulation redo\nRead Fundamentals of Photonics Ch 1, 2, 6\nRead Boyd NLO Ch 1\nTidy3D Python Tutorial 1 and 2\n\n\n\nTidy3D Learning Outline\nFDTD 101:\n\nIntroduction to FDTD Simulation\nUsing FDTD to compute transmission spectrum\nMode Injection\nModeling Dispersive materials in FDTD\nIntroduction to PML\nTimestep size and CFL conditions\nNumerical Dispersion in FDTD\nDielectric constant assignment on Yee Grids\nSubpixel Averaging\n\nTidy3D Python:\n\nBasics\nMediums\nStructures\nGrid Specifications\nBoundary Conditions and Symmetry\nSources\nData visualization and Postprocessing"
  },
  {
    "objectID": "log.slides.html#week-2-912025-972025",
    "href": "log.slides.html#week-2-912025-972025",
    "title": "Work Log",
    "section": "Week 2 [9/1/2025-9/7/2025]",
    "text": "Week 2 [9/1/2025-9/7/2025]\nTidy3D:\n\nMesh Study (P/2, P/4, P/8, P/16, P/32, …) on huygens metasurface and plot the transmission\nUnderstand how to calculate phase (Example)\nLearn how to use material library and define circular polarization (Example)\nRegenerate Figure 2B (Ultra narrowband geometric-phase resonant metasurfaces)\n\nNonlinear Optics:\nClasses so far:\n\nNonlinear susceptibility; anharmonic oscillator\nProperties of the nonlinear susceptibility; K.-K. relations 1.5—1.7\nWave equation in NLO; Coupled-wave equations for SFG 2.1—2.2\n\nSelf-Study:\n\nIIT Lectures 1-20\nBYU notebooks (implement 1, 2, 3, 4)\n\nAdvanced Optics:\nClasses so far:\n\nRay Optics, Graded Index Optics, Matrix Optics\nWave Optics, Paraxial Waves\nDiffraction/Transmission/Reflection\nGaussian Beams, ABCD matrices, etalons, thin films, cavities\nGuided wave optics, optical fibers, waveguides\n\nSelf-Study:\n\nFOP by Saleh 1, 2, 3, 6, 9, 11"
  },
  {
    "objectID": "log.slides.html#week-1-8252025-8312025",
    "href": "log.slides.html#week-1-8252025-8312025",
    "title": "Work Log",
    "section": "Week 1 [8/25/2025-8/31/2025]",
    "text": "Week 1 [8/25/2025-8/31/2025]\n\nTidy3D Huygen’s metasurface simulation redo\nRead Fundamentals of Photonics Ch 1, 2, 6\nRead Boyd NLO Ch 1\nTidy3D Python Tutorial 1 and 2"
  },
  {
    "objectID": "log.slides.html#tidy3d-learning-outline",
    "href": "log.slides.html#tidy3d-learning-outline",
    "title": "Work Log",
    "section": "Tidy3D Learning Outline",
    "text": "Tidy3D Learning Outline\nFDTD 101:\n\nIntroduction to FDTD Simulation\nUsing FDTD to compute transmission spectrum\nMode Injection\nModeling Dispersive materials in FDTD\nIntroduction to PML\nTimestep size and CFL conditions\nNumerical Dispersion in FDTD\nDielectric constant assignment on Yee Grids\nSubpixel Averaging\n\nTidy3D Python:\n\nBasics\nMediums\nStructures\nGrid Specifications\nBoundary Conditions and Symmetry\nSources\nData visualization and Postprocessing"
  },
  {
    "objectID": "courses/optics.html",
    "href": "courses/optics.html",
    "title": "Learning Optics",
    "section": "",
    "text": "Picturing light as rays is useful for predicting imaging properties.\nAs \\lambda \\rightarrow 0, Maxwell equation’s become the eikonal equation, which governs ray direction in a medium with a varying n(\\vec{r}).\nFermat’s principle is deduced from eikonal equation.\nSnell’s law is derived from fermat’s principle.\n\n\n\nWave equation in isotropic medium:\n\\nabla^2 \\vec{E}(\\vec{r}, t) + \\frac{[n(\\vec{r})]^2 \\omega^2}{c^2} \\vec{E}(\\vec{r}, t) = 0\nTrial solution:\n\\vec{E}(\\vec{r}, t) = \\vec{E}_0 e^{i[k_{vac} R(\\vec{r}) - \\omega t]}, k_{vac} = \\frac{\\omega}{c} \\left( \\frac{rad}{m} \\right)\nWe plug trial solution in, perform laplacian, arrange terms, and make the approximation that \\frac{1}{k_{vac}} = \\frac{\\lambda_{vac}}{2 \\pi} \\rightarrow 0, we get the simplified wave equation\n[\\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) - [n(\\vec{r})]^2] \\vec{E}_0(\\vec{r}) = 0\n\\implies \\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) = [n(\\vec{r})]^2\n\\implies \\boxed{ \\nabla R(\\vec{r}) = n(\\vec{r}) \\hat{s}(\\vec{r}) }\nIf R(\\vec{r}) (length) is real, no absorption or amplification. R(\\vec{r}) = constant is one wavefront. \\nabla R(\\vec{r}) is the local direction of propagation. \\hat{s} is unit vector in direction of energy flow. Rays are collection vectors \\hat{s}.\n\n\n\nCurl of eikonal function is\n\\nabla \\times [\\nabla R(\\vec{r})] = \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0 \nIntegrating over open surface A, we get\n\\int_{A} \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0  \\tag{}\nApply Stoke’s Theorem, we have\n\\oint_{C} n \\hat{s} \\cdot d\\vec{l} = 0\n\\implies \\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l}\nNotice that\n\\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l} = \\min{\\int_{A}^{B} n d \\vec{l}}\nWe define Optical Path Length as\n\\boxed{OPL = \\int_{A}^{B} n dl}\nAnd Fermat’s Theorem minimizes travel time,\n\\delta t = \\frac{OPL}{c}\n\n\n\nPropagation of rays through optical systems can be approximated as paraxial, nearly parallel to the axis of these systems.\nParaxial ray theory predicts stability of laser cavities, to see if ray drift away from optical axis.\n\n\n\n\n\n\nConstruction to prove Snell’s Law\n\n\nConstrained minimization problem: Minimize $n_1 d_1 _1 + $",
    "crumbs": [
      "Courses",
      "Learning Optics"
    ]
  },
  {
    "objectID": "courses/optics.html#ray-optics",
    "href": "courses/optics.html#ray-optics",
    "title": "Learning Optics",
    "section": "",
    "text": "Picturing light as rays is useful for predicting imaging properties.\nAs \\lambda \\rightarrow 0, Maxwell equation’s become the eikonal equation, which governs ray direction in a medium with a varying n(\\vec{r}).\nFermat’s principle is deduced from eikonal equation.\nSnell’s law is derived from fermat’s principle.\n\n\n\nWave equation in isotropic medium:\n\\nabla^2 \\vec{E}(\\vec{r}, t) + \\frac{[n(\\vec{r})]^2 \\omega^2}{c^2} \\vec{E}(\\vec{r}, t) = 0\nTrial solution:\n\\vec{E}(\\vec{r}, t) = \\vec{E}_0 e^{i[k_{vac} R(\\vec{r}) - \\omega t]}, k_{vac} = \\frac{\\omega}{c} \\left( \\frac{rad}{m} \\right)\nWe plug trial solution in, perform laplacian, arrange terms, and make the approximation that \\frac{1}{k_{vac}} = \\frac{\\lambda_{vac}}{2 \\pi} \\rightarrow 0, we get the simplified wave equation\n[\\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) - [n(\\vec{r})]^2] \\vec{E}_0(\\vec{r}) = 0\n\\implies \\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) = [n(\\vec{r})]^2\n\\implies \\boxed{ \\nabla R(\\vec{r}) = n(\\vec{r}) \\hat{s}(\\vec{r}) }\nIf R(\\vec{r}) (length) is real, no absorption or amplification. R(\\vec{r}) = constant is one wavefront. \\nabla R(\\vec{r}) is the local direction of propagation. \\hat{s} is unit vector in direction of energy flow. Rays are collection vectors \\hat{s}.\n\n\n\nCurl of eikonal function is\n\\nabla \\times [\\nabla R(\\vec{r})] = \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0 \nIntegrating over open surface A, we get\n\\int_{A} \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0  \\tag{}\nApply Stoke’s Theorem, we have\n\\oint_{C} n \\hat{s} \\cdot d\\vec{l} = 0\n\\implies \\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l}\nNotice that\n\\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l} = \\min{\\int_{A}^{B} n d \\vec{l}}\nWe define Optical Path Length as\n\\boxed{OPL = \\int_{A}^{B} n dl}\nAnd Fermat’s Theorem minimizes travel time,\n\\delta t = \\frac{OPL}{c}\n\n\n\nPropagation of rays through optical systems can be approximated as paraxial, nearly parallel to the axis of these systems.\nParaxial ray theory predicts stability of laser cavities, to see if ray drift away from optical axis.\n\n\n\n\n\n\nConstruction to prove Snell’s Law\n\n\nConstrained minimization problem: Minimize $n_1 d_1 _1 + $",
    "crumbs": [
      "Courses",
      "Learning Optics"
    ]
  },
  {
    "objectID": "courses/optics.html#citations",
    "href": "courses/optics.html#citations",
    "title": "Learning Optics",
    "section": "Citations",
    "text": "Citations\n[1] Saleh, B. E. A., & Teich, M. C. (2019). Fundamentals of photonics (3rd ed.). Wiley. [2] Peatross, Justin, and Michael Ware. Physics of Light and Optics. 2015 ed., January 31, 2025 revision, Department of Physics, Brigham Young University. optics.byu.edu.",
    "crumbs": [
      "Courses",
      "Learning Optics"
    ]
  },
  {
    "objectID": "courses/optics.slides.html#introduction",
    "href": "courses/optics.slides.html#introduction",
    "title": "Learning Optics",
    "section": "Introduction",
    "text": "Introduction\nPicturing light as rays is useful for predicting imaging properties.\nAs \\lambda \\rightarrow 0, Maxwell equation’s become the eikonal equation, which governs ray direction in a medium with a varying n(\\vec{r}).\nFermat’s principle is deduced from eikonal equation.\nSnell’s law is derived from fermat’s principle."
  },
  {
    "objectID": "courses/optics.slides.html#the-eikonal-equation",
    "href": "courses/optics.slides.html#the-eikonal-equation",
    "title": "Learning Optics",
    "section": "The Eikonal Equation",
    "text": "The Eikonal Equation\nWave equation in isotropic medium:\n\\nabla^2 \\vec{E}(\\vec{r}, t) + \\frac{[n(\\vec{r})]^2 \\omega^2}{c^2} \\vec{E}(\\vec{r}, t) = 0\nTrial solution:\n\\vec{E}(\\vec{r}, t) = \\vec{E}_0 e^{i[k_{vac} R(\\vec{r}) - \\omega t]}, k_{vac} = \\frac{\\omega}{c} \\left( \\frac{rad}{m} \\right)\nWe plug trial solution in, perform laplacian, arrange terms, and make the approximation that \\frac{1}{k_{vac}} = \\frac{\\lambda_{vac}}{2 \\pi} \\rightarrow 0, we get the simplified wave equation\n[\\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) - [n(\\vec{r})]^2] \\vec{E}_0(\\vec{r}) = 0\n\\implies \\nabla R(\\vec{r}) \\cdot \\nabla R(\\vec{r}) = [n(\\vec{r})]^2\n\\implies \\boxed{ \\nabla R(\\vec{r}) = n(\\vec{r}) \\hat{s}(\\vec{r}) }\nIf R(\\vec{r}) (length) is real, no absorption or amplification. R(\\vec{r}) = constant is one wavefront. \\nabla R(\\vec{r}) is the local direction of propagation. \\hat{s} is unit vector in direction of energy flow. Rays are collection vectors \\hat{s}."
  },
  {
    "objectID": "courses/optics.slides.html#fermats-principle",
    "href": "courses/optics.slides.html#fermats-principle",
    "title": "Learning Optics",
    "section": "Fermat’s Principle",
    "text": "Fermat’s Principle\nCurl of eikonal function is\n\\nabla \\times [\\nabla R(\\vec{r})] = \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0 \nIntegrating over open surface A, we get\n\\int_{A} \\nabla \\times [n(\\vec{r}) \\hat{s}(\\vec{r})] = 0  \\tag{}\nApply Stoke’s Theorem, we have\n\\oint_{C} n \\hat{s} \\cdot d\\vec{l} = 0\n\\implies \\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l}\nNotice that\n\\int_{A}^{B} n \\hat{s} \\cdot d\\vec{l} = \\min{\\int_{A}^{B} n d \\vec{l}}\nWe define Optical Path Length as\n\\boxed{OPL = \\int_{A}^{B} n dl}\nAnd Fermat’s Theorem minimizes travel time,\n\\delta t = \\frac{OPL}{c}"
  },
  {
    "objectID": "courses/optics.slides.html#paraxial-ray-theory",
    "href": "courses/optics.slides.html#paraxial-ray-theory",
    "title": "Learning Optics",
    "section": "Paraxial Ray Theory",
    "text": "Paraxial Ray Theory\nPropagation of rays through optical systems can be approximated as paraxial, nearly parallel to the axis of these systems.\nParaxial ray theory predicts stability of laser cavities, to see if ray drift away from optical axis."
  },
  {
    "objectID": "courses/optics.slides.html#proof-of-snells-law",
    "href": "courses/optics.slides.html#proof-of-snells-law",
    "title": "Learning Optics",
    "section": "Proof of Snell’s Law",
    "text": "Proof of Snell’s Law\n\nConstruction to prove Snell’s LawConstrained minimization problem: Minimize $n_1 d_1 _1 + $"
  },
  {
    "objectID": "index.slides.html#about-me",
    "href": "index.slides.html#about-me",
    "title": "Yankun (Alex) Meng",
    "section": "About Me",
    "text": "About Me\nI am a first-year PhD student in the Department of Electrical and Computer Engineering at Duke University, fortunate to be advised by Prof. Natalia M. Litchinitser.\nPreviously, I was an undergrad at Duke University Double majoring in Electrical and Computer Engineering and Computer Science."
  },
  {
    "objectID": "index.slides.html#news",
    "href": "index.slides.html#news",
    "title": "Yankun (Alex) Meng",
    "section": "News",
    "text": "News\n[August 2025] PhD started!\n[May 2025] Graduated from Duke Undergraduate"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Yankun (Alex) Meng",
    "section": "",
    "text": "About Me\nI am a first-year PhD student in the Department of Electrical and Computer Engineering at Duke University, fortunate to be advised by Prof. Natalia M. Litchinitser.\nPreviously, I was an undergrad at Duke University Double majoring in Electrical and Computer Engineering and Computer Science.\n\n\nNews\n[August 2025] PhD started!\n[May 2025] Graduated from Duke Undergraduate",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "nlo.slides.html#basic-linear-optics",
    "href": "nlo.slides.html#basic-linear-optics",
    "title": "Nonlinear Optics",
    "section": "Basic Linear Optics",
    "text": "Basic Linear Optics\nMaxwell’s Equation"
  },
  {
    "objectID": "nlo.slides.html#nonlinear-optics",
    "href": "nlo.slides.html#nonlinear-optics",
    "title": "Nonlinear Optics",
    "section": "Nonlinear Optics",
    "text": "Nonlinear Optics\nIntroduction"
  },
  {
    "objectID": "nlo.html",
    "href": "nlo.html",
    "title": "Nonlinear Optics",
    "section": "",
    "text": "Nonlinear Optics BYU Nonlinear Optics IIT\n\nBasic Linear Optics\n\nMaxwell’s Equation\n\n\n\nMaxwell’s Wave Equation\n\n\n\nPlane wave and solution of the wave equation\n\n\n\nMonochromatic and Non-monochromatic waves\n\n\n\nElectric displacement, electric polarization, and refractice index\n\n\n\nDirection of E, D, and k in an isotropic medium\n\n\n\nPoynting vector and energy flow\n\n\n\nIntensity of an EM wave\n\n\n\nAnisotropic media\n\n\n\nSusceptibility Tensor\n\n\n\nEM Wave Propagation in Anisotropic media\n\n\n\nOrdinary and Extra-ordinary ray\n\n\n\nIndex Ellipsoid\n\n\n\nLinear response and polarization\n\n\n\nDielectric Susceptibility\n\n\n\n\nNonlinear Optics\n\nIntroduction\n\n\n\nClassical Origin of nonlinearity\n\n\n\nMiller’s Rule\n\n\n\nDimensions of higher order susceptibiltiies\n\n\n\nSecond Harmonic Generation (SHG)\n\n\n\nOptical REctification\n\n\n\nLinear Electro-optic effect\n\n\n\nSum and Difference Frequency Generation\n\n\n\nNonlinear Maxwell’s Equation\n\n\n\nTheory of SHG\n\n\n\nPhase Matching\n\n\n\nGain Bandwidth\n\n\n\nManley-Rowe Relation\n\n\n\nEnergy Conservation in SHG\n\n\n\nDifferent kinds of phase matching\n\n\n\nBirefringence phase-matching\n\n\n\nType I Phase Matching\n\n\n\nType II Phase Matching\n\n\n\nSymmetry in nonlinear susceptibility\n\n\n\nKleinman’s Symmetry\n\n\n\nNeumann’s Principle"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#introduction",
    "href": "simulation/tidy3d.slides.html#introduction",
    "title": "Tidy3D",
    "section": "Introduction",
    "text": "Introduction\nFDTD method allows you to compute the evolution of electromagnetic field in the time domain.\nGiven some device \\epsilon(\\vec{r}) and an incident field or current source \\vec{J}(\\vec{r}, t), internally, FDTD solves these maxwell’s equations:\n\\nabla \\times \\vec{E}(\\vec{r}, t) = -\\mu_0 \\frac{\\vec{H}(\\vec{r}, t)}{dt} \\tag{1}\n\\nabla \\times \\vec{H}(\\vec{r}, t) = \\epsilon(\\vec{r}) \\epsilon_0 \\frac{d\\vec{E}(\\vec{r}, t)}{dt} + \\vec{J}(\\vec{r}, t) \\tag{2}\n\nField Update\nThe diagram is from Simulation Documentation"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#starting-tidy3d",
    "href": "simulation/tidy3d.slides.html#starting-tidy3d",
    "title": "Tidy3D",
    "section": "Starting Tidy3D",
    "text": "Starting Tidy3D\nThese software packages should be imported everytime you start a tidy3D project:\nimport tidy3d as td # Main package\nimport tidy3d.web as web # Used to run the simulation\nimport matplotlib.pyplot as plt # Used for plotting results\nimport numpy as np # Used for numerical calculations"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#before-simulation",
    "href": "simulation/tidy3d.slides.html#before-simulation",
    "title": "Tidy3D",
    "section": "Before Simulation",
    "text": "Before Simulation\nBefore the simulation, we have to define some key parameters of the electromagnetic waves that we will use across the simulation:\nlambda_range = (1.1, 1.6)   # wavelength range (µm)\nfreqs = (td.C_0 / lambda_range[1], td.C_0 / lambda_range[0])  # frequency range\nfreq0 = np.mean(freqs)      # center frequency\nlda0 = td.C_0 / freq0       # center wavelength\nbandwidth = 0.38            # normalized bandwidth\nfreqw = bandwidth * (freqs[1] - freqs[0])  # bandwidth in Hz\nNote: All numbers in tidy3d are in microns (\\mu m)"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#basic-workflow",
    "href": "simulation/tidy3d.slides.html#basic-workflow",
    "title": "Tidy3D",
    "section": "Basic Workflow",
    "text": "Basic Workflow\nHere’s how to simulate something:\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # inputs\n)\nThe most basic way of running the simulation is using the web object we imported from tidy3d:\n# Running a simulation\nsim1_data = web.run(simulation1, task_name='any-unique-name', path='data/descriptive-name.hdf5')\nSimulation data is stored as an HDF5 file at the file path you specify.\n\nSee Simulation Documentation for more information"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#simulation-inputs",
    "href": "simulation/tidy3d.slides.html#simulation-inputs",
    "title": "Tidy3D",
    "section": "Simulation Inputs",
    "text": "Simulation Inputs\nThe 7 required inputs are:\n\nComputational Domain Size\nGrid Specifications (Discretization size)\nStructures\nSources\nMonitors\nRun time\nBoundary Condition Specification\n\nWe will introduce these 7 parameters by simulating a huygen’s metasurface\n\nSee Simulation Documentation for more information"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#computational-domain-size",
    "href": "simulation/tidy3d.slides.html#computational-domain-size",
    "title": "Tidy3D",
    "section": "1 Computational Domain Size",
    "text": "1 Computational Domain Size\nSize in x, y, and z directions.\np = 0.666 #nm -&gt; Periodicity\nLx, Ly, Lz = p, p, 2 * lda0 \nsim_size = [Lx, Ly, Lz]\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = sim_size\n)"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#grid-specifications",
    "href": "simulation/tidy3d.slides.html#grid-specifications",
    "title": "Tidy3D",
    "section": "2 Grid Specifications",
    "text": "2 Grid Specifications\nSpecifications for the simulation grid along each of the three directions.\n# Define Grid size\nspec = td.GridSpec.auto(min_steps_per_wvl=40, wavelength=lda0)\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = (x, y, z),\n    grid_spec=spec,\n    \n)\n\nTypically, the size of a unit cell is \\frac{\\lambda}{20}"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#structures",
    "href": "simulation/tidy3d.slides.html#structures",
    "title": "Tidy3D",
    "section": "3 Structures",
    "text": "3 Structures\ntd.Structure is the meat of the simulation. It defines a physical object that interacts with the electromagnetic fields. The structures field is a tuple of Structure objects that you create.\n# set up simulation\nsim = td.Simulation(\n    size=sim_size,\n    grid_spec=spec,\n    structures=[superstrate, substrate, cylinder],"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#sources",
    "href": "simulation/tidy3d.slides.html#sources",
    "title": "Tidy3D",
    "section": "4 Sources",
    "text": "4 Sources\nTuple of electric current sources injecting fields into the simulation. Common ones are:\nPlane Wave - Uniform current distribution on an infinite extent plane. (Doc)\npulse = GaussianPulse(freq0=200e12, fwidth=20e12)\npw_source = PlaneWave(size=(inf,0,inf), source_time=pulse, pol_angle=0.1, direction='+')\nPoint Dipole - Uniform current source with a zero size. (Doc)\npulse = td.GaussianPulse(freq0=200e12, fwidth=20e12)\npt_dipole = td.PointDipole(center=(1,2,3), source_time=pulse, polarization='Ex')\nSee documentation for Other Sources"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#monitors",
    "href": "simulation/tidy3d.slides.html#monitors",
    "title": "Tidy3D",
    "section": "5 Monitors",
    "text": "5 Monitors\nTuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.\nSee Other monitors"
  },
  {
    "objectID": "simulation/tidy3d.slides.html#run-time",
    "href": "simulation/tidy3d.slides.html#run-time",
    "title": "Tidy3D",
    "section": "6 Run time",
    "text": "6 Run time\nTotal electromagnetic evolution time in seconds."
  },
  {
    "objectID": "simulation/tidy3d.slides.html#boundary-condition-specification",
    "href": "simulation/tidy3d.slides.html#boundary-condition-specification",
    "title": "Tidy3D",
    "section": "7 Boundary Condition Specification",
    "text": "7 Boundary Condition Specification\nSpecification of boundary conditions along each dimension. If None, PML boundary conditions are applied on all sides."
  },
  {
    "objectID": "simulation/tidy3d.slides.html#bonus-symmetry",
    "href": "simulation/tidy3d.slides.html#bonus-symmetry",
    "title": "Tidy3D",
    "section": "Bonus: Symmetry",
    "text": "Bonus: Symmetry\nTuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectively. Each element can be 0 (no symmetry), 1 (even, i.e. ‘PMC’ symmetry) or -1 (odd, i.e. ‘PEC’ symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.\nSymmetry can be used to greatly reduce the computational cost –&gt;"
  },
  {
    "objectID": "simulation/tidy3d.html",
    "href": "simulation/tidy3d.html",
    "title": "Tidy3D",
    "section": "",
    "text": "FDTD method allows you to compute the evolution of electromagnetic field in the time domain.\nGiven some device \\epsilon(\\vec{r}) and an incident field or current source \\vec{J}(\\vec{r}, t), internally, FDTD solves these maxwell’s equations:\n\\nabla \\times \\vec{E}(\\vec{r}, t) = -\\mu_0 \\frac{\\vec{H}(\\vec{r}, t)}{dt} \\tag{1}\n\\nabla \\times \\vec{H}(\\vec{r}, t) = \\epsilon(\\vec{r}) \\epsilon_0 \\frac{d\\vec{E}(\\vec{r}, t)}{dt} + \\vec{J}(\\vec{r}, t) \\tag{2}\n\n\n\nField Update\n\n\n\nThe diagram is from Simulation Documentation\n\n\n\n\nThese software packages should be imported everytime you start a tidy3D project:\nimport tidy3d as td # Main package\nimport tidy3d.web as web # Used to run the simulation\nimport matplotlib.pyplot as plt # Used for plotting results\nimport numpy as np # Used for numerical calculations\n\n\n\nBefore the simulation, we have to define some key parameters of the electromagnetic waves that we will use across the simulation:\nlambda_range = (1.1, 1.6)   # wavelength range (µm)\nfreqs = (td.C_0 / lambda_range[1], td.C_0 / lambda_range[0])  # frequency range\nfreq0 = np.mean(freqs)      # center frequency\nlda0 = td.C_0 / freq0       # center wavelength\nbandwidth = 0.38            # normalized bandwidth\nfreqw = bandwidth * (freqs[1] - freqs[0])  # bandwidth in Hz\nNote: All numbers in tidy3d are in microns (\\mu m)\n\n\n\nHere’s how to simulate something:\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # inputs\n)\nThe most basic way of running the simulation is using the web object we imported from tidy3d:\n# Running a simulation\nsim1_data = web.run(simulation1, task_name='any-unique-name', path='data/descriptive-name.hdf5')\nSimulation data is stored as an HDF5 file at the file path you specify.\n\nSee Simulation Documentation for more information\n\n\n\n\nThe 7 required inputs are:\n\n\nComputational Domain Size\nGrid Specifications (Discretization size)\nStructures\nSources\nMonitors\nRun time\nBoundary Condition Specification\n\n\nWe will introduce these 7 parameters by simulating a huygen’s metasurface\n\nSee Simulation Documentation for more information\n\n\n\n\nSize in x, y, and z directions.\np = 0.666 #nm -&gt; Periodicity\nLx, Ly, Lz = p, p, 2 * lda0 \nsim_size = [Lx, Ly, Lz]\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = sim_size\n)\n\n\n\nSpecifications for the simulation grid along each of the three directions.\n# Define Grid size\nspec = td.GridSpec.auto(min_steps_per_wvl=40, wavelength=lda0)\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = (x, y, z),\n    grid_spec=spec,\n    \n)\n\nTypically, the size of a unit cell is \\frac{\\lambda}{20}\n\n\ntd.GridSpec contains many functions to help define the grid, the most commonly used are:\ntd.GridSpec.uniform(dl=grid_size)\ntd.GridSpec.auto(min_steps_per_wvl=40, wavelength=lda0)\n\nuniform - Use the same Uniform 1D grid along each of the three directions.\n\ndl (float) – Grid size for uniform grid generation.\n\nauto - Use the same non-uniform grid along each of the three directions.\n\nmin_steps_per_wvl(ConstrainedFloatValue = 10.0) – Minimal number of steps per wavelength in each medium.\nwavelength (float) – Wavelength to use for the step size and for dispersive media epsilon.\n\n\n\n\n\ntd.Structure is the meat of the simulation. It defines a physical object that interacts with the electromagnetic fields. The structures field is a tuple of Structure objects that you create.\n# set up simulation\nsim = td.Simulation(\n    size=sim_size,\n    grid_spec=spec,\n    structures=[superstrate, substrate, cylinder],\n\n# set up simulation\ntd.Structure(\n   # inputs\n)\nA structure needs two inputs at least: - geometry (td.Box, td.Cylinder, td.Sphere, td.TriangleMesh (STL file), etc.) - medium Mediums define the optical properties of the materials within the simulation. (e.g. td.Medium)\n\nAccording to the paper on huygen’s metasurface, I defined these four structures:\nt = 2  # thickness of the substrate # THIS SHOULD BE CHANGED TO INFINITE\nsubstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,-t/2),\n        size=(td.inf,td.inf,t)\n    ),\n    medium=td.Medium(permittivity=1.45**2, name='oxide'),\n    name='substrate'\n)\nsuperstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,t/2),\n        size=(td.inf,td.inf,t)\n    ),\n    medium=td.Medium(permittivity=1.4**2, name='glass'),\n    name='superstrate'\n)\npolymer = td.Structure(\n    geometry=td.Box(\n        center=(0,0,0),\n        size=(td.inf,td.inf,2*t)\n    ),\n    medium=td.Medium(permittivity=1.66**2, name='polymer'),\n    name='polymer'\n)\n# construct the silicon resonator\ncylinder = td.Structure(\n    geometry=td.Cylinder(center=[0, 0, h / 2], radius=r, length=h, axis=2), medium=td.Medium(permittivity=3.5**2, name='Si')\n)\n\n\n\nTuple of electric current sources injecting fields into the simulation. Common ones are:\nPlane Wave - Uniform current distribution on an infinite extent plane. (Doc)\npulse = GaussianPulse(freq0=200e12, fwidth=20e12)\npw_source = PlaneWave(size=(inf,0,inf), source_time=pulse, pol_angle=0.1, direction='+')\nPoint Dipole - Uniform current source with a zero size. (Doc)\npulse = td.GaussianPulse(freq0=200e12, fwidth=20e12)\npt_dipole = td.PointDipole(center=(1,2,3), source_time=pulse, polarization='Ex')\nSee documentation for Other Sources\n\nIn this case, I defined one plane wave source:\n# add a plane wave source\nplane_wave = td.PlaneWave(\n    source_time=td.GaussianPulse(freq0=freq0, fwidth=0.5 * freqw),\n    size=(td.inf, td.inf, 0),\n    center=(0, 0, 0.3 * lda0),\n    direction=\"-\",\n    pol_angle=0,\n)\n\n\n\nTuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.\nSee Other monitors\n\n\n\nTotal electromagnetic evolution time in seconds.\n\n\n\nSpecification of boundary conditions along each dimension. If None, PML boundary conditions are applied on all sides.\n\n\n\nTuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectively. Each element can be 0 (no symmetry), 1 (even, i.e. ‘PMC’ symmetry) or -1 (odd, i.e. ‘PEC’ symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.\nSymmetry can be used to greatly reduce the computational cost –&gt;",
    "crumbs": [
      "Python",
      "Tidy3D"
    ]
  },
  {
    "objectID": "simulation/tidy3d.html#introduction-to-tidy3d",
    "href": "simulation/tidy3d.html#introduction-to-tidy3d",
    "title": "Tidy3D",
    "section": "",
    "text": "FDTD method allows you to compute the evolution of electromagnetic field in the time domain.\nGiven some device \\epsilon(\\vec{r}) and an incident field or current source \\vec{J}(\\vec{r}, t), internally, FDTD solves these maxwell’s equations:\n\\nabla \\times \\vec{E}(\\vec{r}, t) = -\\mu_0 \\frac{\\vec{H}(\\vec{r}, t)}{dt} \\tag{1}\n\\nabla \\times \\vec{H}(\\vec{r}, t) = \\epsilon(\\vec{r}) \\epsilon_0 \\frac{d\\vec{E}(\\vec{r}, t)}{dt} + \\vec{J}(\\vec{r}, t) \\tag{2}\n\n\n\nField Update\n\n\n\nThe diagram is from Simulation Documentation\n\n\n\n\nThese software packages should be imported everytime you start a tidy3D project:\nimport tidy3d as td # Main package\nimport tidy3d.web as web # Used to run the simulation\nimport matplotlib.pyplot as plt # Used for plotting results\nimport numpy as np # Used for numerical calculations\n\n\n\nBefore the simulation, we have to define some key parameters of the electromagnetic waves that we will use across the simulation:\nlambda_range = (1.1, 1.6)   # wavelength range (µm)\nfreqs = (td.C_0 / lambda_range[1], td.C_0 / lambda_range[0])  # frequency range\nfreq0 = np.mean(freqs)      # center frequency\nlda0 = td.C_0 / freq0       # center wavelength\nbandwidth = 0.38            # normalized bandwidth\nfreqw = bandwidth * (freqs[1] - freqs[0])  # bandwidth in Hz\nNote: All numbers in tidy3d are in microns (\\mu m)\n\n\n\nHere’s how to simulate something:\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # inputs\n)\nThe most basic way of running the simulation is using the web object we imported from tidy3d:\n# Running a simulation\nsim1_data = web.run(simulation1, task_name='any-unique-name', path='data/descriptive-name.hdf5')\nSimulation data is stored as an HDF5 file at the file path you specify.\n\nSee Simulation Documentation for more information\n\n\n\n\nThe 7 required inputs are:\n\n\nComputational Domain Size\nGrid Specifications (Discretization size)\nStructures\nSources\nMonitors\nRun time\nBoundary Condition Specification\n\n\nWe will introduce these 7 parameters by simulating a huygen’s metasurface\n\nSee Simulation Documentation for more information\n\n\n\n\nSize in x, y, and z directions.\np = 0.666 #nm -&gt; Periodicity\nLx, Ly, Lz = p, p, 2 * lda0 \nsim_size = [Lx, Ly, Lz]\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = sim_size\n)\n\n\n\nSpecifications for the simulation grid along each of the three directions.\n# Define Grid size\nspec = td.GridSpec.auto(min_steps_per_wvl=40, wavelength=lda0)\n\n# Defining a simulation\nsimulation1 = td.Simulation(\n    # A square computational domain\n    size = (x, y, z),\n    grid_spec=spec,\n    \n)\n\nTypically, the size of a unit cell is \\frac{\\lambda}{20}\n\n\ntd.GridSpec contains many functions to help define the grid, the most commonly used are:\ntd.GridSpec.uniform(dl=grid_size)\ntd.GridSpec.auto(min_steps_per_wvl=40, wavelength=lda0)\n\nuniform - Use the same Uniform 1D grid along each of the three directions.\n\ndl (float) – Grid size for uniform grid generation.\n\nauto - Use the same non-uniform grid along each of the three directions.\n\nmin_steps_per_wvl(ConstrainedFloatValue = 10.0) – Minimal number of steps per wavelength in each medium.\nwavelength (float) – Wavelength to use for the step size and for dispersive media epsilon.\n\n\n\n\n\ntd.Structure is the meat of the simulation. It defines a physical object that interacts with the electromagnetic fields. The structures field is a tuple of Structure objects that you create.\n# set up simulation\nsim = td.Simulation(\n    size=sim_size,\n    grid_spec=spec,\n    structures=[superstrate, substrate, cylinder],\n\n# set up simulation\ntd.Structure(\n   # inputs\n)\nA structure needs two inputs at least: - geometry (td.Box, td.Cylinder, td.Sphere, td.TriangleMesh (STL file), etc.) - medium Mediums define the optical properties of the materials within the simulation. (e.g. td.Medium)\n\nAccording to the paper on huygen’s metasurface, I defined these four structures:\nt = 2  # thickness of the substrate # THIS SHOULD BE CHANGED TO INFINITE\nsubstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,-t/2),\n        size=(td.inf,td.inf,t)\n    ),\n    medium=td.Medium(permittivity=1.45**2, name='oxide'),\n    name='substrate'\n)\nsuperstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,t/2),\n        size=(td.inf,td.inf,t)\n    ),\n    medium=td.Medium(permittivity=1.4**2, name='glass'),\n    name='superstrate'\n)\npolymer = td.Structure(\n    geometry=td.Box(\n        center=(0,0,0),\n        size=(td.inf,td.inf,2*t)\n    ),\n    medium=td.Medium(permittivity=1.66**2, name='polymer'),\n    name='polymer'\n)\n# construct the silicon resonator\ncylinder = td.Structure(\n    geometry=td.Cylinder(center=[0, 0, h / 2], radius=r, length=h, axis=2), medium=td.Medium(permittivity=3.5**2, name='Si')\n)\n\n\n\nTuple of electric current sources injecting fields into the simulation. Common ones are:\nPlane Wave - Uniform current distribution on an infinite extent plane. (Doc)\npulse = GaussianPulse(freq0=200e12, fwidth=20e12)\npw_source = PlaneWave(size=(inf,0,inf), source_time=pulse, pol_angle=0.1, direction='+')\nPoint Dipole - Uniform current source with a zero size. (Doc)\npulse = td.GaussianPulse(freq0=200e12, fwidth=20e12)\npt_dipole = td.PointDipole(center=(1,2,3), source_time=pulse, polarization='Ex')\nSee documentation for Other Sources\n\nIn this case, I defined one plane wave source:\n# add a plane wave source\nplane_wave = td.PlaneWave(\n    source_time=td.GaussianPulse(freq0=freq0, fwidth=0.5 * freqw),\n    size=(td.inf, td.inf, 0),\n    center=(0, 0, 0.3 * lda0),\n    direction=\"-\",\n    pol_angle=0,\n)\n\n\n\nTuple of monitors in the simulation. Note: monitor names are used to access data after simulation is run.\nSee Other monitors\n\n\n\nTotal electromagnetic evolution time in seconds.\n\n\n\nSpecification of boundary conditions along each dimension. If None, PML boundary conditions are applied on all sides.\n\n\n\nTuple of integers defining reflection symmetry across a plane bisecting the simulation domain normal to the x-, y-, and z-axis at the simulation center of each axis, respectively. Each element can be 0 (no symmetry), 1 (even, i.e. ‘PMC’ symmetry) or -1 (odd, i.e. ‘PEC’ symmetry). Note that the vectorial nature of the fields must be taken into account to correctly determine the symmetry value.\nSymmetry can be used to greatly reduce the computational cost –&gt;",
    "crumbs": [
      "Python",
      "Tidy3D"
    ]
  },
  {
    "objectID": "simulation/diffraction_monitor.slides.html#diffraction-monitor-results",
    "href": "simulation/diffraction_monitor.slides.html#diffraction-monitor-results",
    "title": "Diffraction Monitor in Tidy3D",
    "section": "Diffraction Monitor Results",
    "text": "Diffraction Monitor Results\n\ndD = batch_data[\"actual\"][\"diffraction_monitor\"]\nnorm_data = batch_data[\"norm\"][\"diffraction_monitor\"]\n\n# diffraction_data.help()\n\n\ndD.monitor\n\nDiffractionMonitor(attrs={}, type='DiffractionMonitor', center=(0.0, 0.0, -0.8718518518518521), size=(inf, inf, 0.0), name='diffraction_monitor', interval_space=(1, 1, 1), colocate=False, freqs=(187370286250000.0, 187654180623106.06, 187938074996212.12, 188221969369318.2, 188505863742424.25, 188789758115530.3, 189073652488636.38, 189357546861742.44, 189641441234848.47, 189925335607954.53, 190209229981060.6, 190493124354166.66, 190777018727272.72, 191060913100378.78, 191344807473484.84, 191628701846590.9, 191912596219696.97, 192196490592803.03, 192480384965909.1, 192764279339015.16, 193048173712121.22, 193332068085227.28, 193615962458333.34, 193899856831439.38, 194183751204545.44, 194467645577651.5, 194751539950757.56, 195035434323863.62, 195319328696969.7, 195603223070075.75, 195887117443181.8, 196171011816287.88, 196454906189393.94, 196738800562500.0, 197022694935606.06, 197306589308712.12, 197590483681818.2, 197874378054924.25, 198158272428030.3, 198442166801136.34, 198726061174242.4, 199009955547348.47, 199293849920454.53, 199577744293560.6, 199861638666666.66, 200145533039772.72, 200429427412878.78, 200713321785984.84, 200997216159090.9, 201281110532196.97, 201565004905303.03, 201848899278409.1, 202132793651515.16, 202416688024621.2, 202700582397727.25, 202984476770833.3, 203268371143939.38, 203552265517045.44, 203836159890151.5, 204120054263257.56, 204403948636363.62, 204687843009469.7, 204971737382575.75, 205255631755681.8, 205539526128787.88, 205823420501893.94, 206107314875000.0, 206391209248106.06, 206675103621212.12, 206958997994318.16, 207242892367424.22, 207526786740530.28, 207810681113636.34, 208094575486742.4, 208378469859848.47, 208662364232954.53, 208946258606060.6, 209230152979166.66, 209514047352272.72, 209797941725378.78, 210081836098484.84, 210365730471590.9, 210649624844696.94, 210933519217803.0, 211217413590909.06, 211501307964015.12, 211785202337121.2, 212069096710227.25, 212352991083333.3, 212636885456439.38, 212920779829545.44, 213204674202651.5, 213488568575757.56, 213772462948863.62, 214056357321969.7, 214340251695075.75, 214624146068181.8, 214908040441287.88, 215191934814393.94, 215475829187499.97, 215759723560606.03, 216043617933712.1, 216327512306818.16, 216611406679924.22, 216895301053030.28, 217179195426136.34, 217463089799242.4, 217746984172348.47, 218030878545454.53, 218314772918560.6, 218598667291666.66, 218882561664772.72, 219166456037878.75, 219450350410984.8, 219734244784090.88, 220018139157196.94, 220302033530303.0, 220585927903409.06, 220869822276515.12, 221153716649621.2, 221437611022727.25, 221721505395833.3, 222005399768939.38, 222289294142045.44, 222573188515151.5, 222857082888257.56, 223140977261363.62, 223424871634469.7, 223708766007575.75, 223992660380681.8, 224276554753787.84, 224560449126893.9, 224844343499999.97, 225128237873106.03, 225412132246212.1, 225696026619318.16, 225979920992424.22, 226263815365530.28, 226547709738636.34, 226831604111742.4, 227115498484848.47, 227399392857954.53, 227683287231060.56, 227967181604166.62, 228251075977272.7, 228534970350378.75, 228818864723484.8, 229102759096590.88, 229386653469696.94, 229670547842803.0, 229954442215909.06, 230238336589015.12, 230522230962121.2, 230806125335227.25, 231090019708333.3, 231373914081439.38, 231657808454545.44, 231941702827651.5, 232225597200757.56, 232509491573863.62, 232793385946969.7, 233077280320075.72, 233361174693181.78, 233645069066287.84, 233928963439393.9, 234212857812499.97, 234496752185606.03, 234780646558712.1, 235064540931818.16, 235348435304924.22, 235632329678030.28, 235916224051136.34, 236200118424242.38, 236484012797348.44, 236767907170454.5, 237051801543560.56, 237335695916666.62, 237619590289772.7, 237903484662878.75, 238187379035984.8, 238471273409090.88, 238755167782196.94, 239039062155303.0, 239322956528409.06, 239606850901515.12, 239890745274621.2, 240174639647727.25, 240458534020833.3, 240742428393939.38, 241026322767045.44, 241310217140151.5, 241594111513257.53, 241878005886363.6, 242161900259469.66, 242445794632575.72, 242729689005681.78, 243013583378787.84, 243297477751893.9, 243581372124999.97, 243865266498106.03, 244149160871212.1, 244433055244318.16, 244716949617424.2, 245000843990530.25, 245284738363636.3, 245568632736742.38, 245852527109848.44, 246136421482954.5, 246420315856060.56, 246704210229166.62, 246988104602272.7, 247271998975378.75, 247555893348484.8, 247839787721590.88, 248123682094696.94, 248407576467803.0, 248691470840909.06, 248975365214015.12, 249259259587121.2, 249543153960227.25, 249827048333333.3, 250110942706439.34, 250394837079545.4, 250678731452651.47, 250962625825757.53, 251246520198863.6, 251530414571969.66, 251814308945075.72, 252098203318181.78, 252382097691287.84, 252665992064393.9, 252949886437499.97, 253233780810606.0, 253517675183712.06, 253801569556818.12, 254085463929924.2, 254369358303030.25, 254653252676136.3, 254937147049242.38, 255221041422348.44, 255504935795454.5, 255788830168560.56, 256072724541666.62, 256356618914772.7, 256640513287878.75, 256924407660984.8, 257208302034090.88, 257492196407196.94, 257776090780303.0, 258059985153409.06, 258343879526515.12, 258627773899621.2, 258911668272727.25, 259195562645833.28, 259479457018939.34, 259763351392045.4, 260047245765151.47, 260331140138257.53, 260615034511363.6, 260898928884469.66, 261182823257575.7, 261466717630681.75, 261750612003787.8, 262034506376893.88, 262318400749999.94, 262602295123106.0, 262886189496212.06, 263170083869318.12, 263453978242424.2, 263737872615530.25, 264021766988636.3, 264305661361742.38, 264589555734848.44, 264873450107954.5, 265157344481060.56, 265441238854166.62, 265725133227272.7, 266009027600378.75, 266292921973484.8, 266576816346590.88, 266860710719696.94, 267144605092803.0, 267428499465909.06, 267712393839015.1, 267996288212121.16, 268280182585227.22, 268564076958333.28, 268847971331439.34, 269131865704545.4, 269415760077651.47, 269699654450757.5, 269983548823863.56, 270267443196969.62, 270551337570075.7, 270835231943181.75, 271119126316287.8, 271403020689393.88, 271686915062499.94, 271970809435606.0, 272254703808712.06, 272538598181818.12), apodization=ApodizationSpec(attrs={}, start=None, end=None, width=None, type='ApodizationSpec'), normal_dir='-')\n\n\n\ndD.Er\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DiffractionDataArray (orders_x: 1, orders_y: 1, f: 301)&gt; Size: 5kB\narray([[[-0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.-0.j,  0.-0.j,  0.-0.j,\n          0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,\n          0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,\n...\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j]]])\nCoordinates:\n  * orders_x  (orders_x) int64 8B 0\n  * orders_y  (orders_y) int64 8B 0\n  * f         (f) float64 2kB 1.874e+14 1.877e+14 ... 2.723e+14 2.725e+14\nAttributes:\n    long_name:  diffraction amplitudexarray.DiffractionDataArrayorders_x: 1orders_y: 1f: 301(-0-0j) (-0-0j) (-0-0j) (-0-0j) (-0-0j) (-0-0j) ... 0j 0j 0j 0j 0j 0jarray([[[-0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.-0.j,  0.-0.j,  0.-0.j,\n          0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,\n          0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,\n...\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j]]])Coordinates: (3)orders_x(orders_x)int640long_name :diffraction orderarray([0])orders_y(orders_y)int640long_name :diffraction orderarray([0])f(f)float641.874e+14 1.877e+14 ... 2.725e+14units :Hzlong_name :frequencyarray([1.873703e+14, 1.876542e+14, 1.879381e+14, ..., 2.719708e+14,\n       2.722547e+14, 2.725386e+14])Indexes: (3)orders_xPandasIndexPandasIndex(Index([0], dtype='int64', name='orders_x'))orders_yPandasIndexPandasIndex(Index([0], dtype='int64', name='orders_y'))fPandasIndexPandasIndex(Index([ 187370286250000.0, 187654180623106.06, 187938074996212.12,\n        188221969369318.2, 188505863742424.25,  188789758115530.3,\n       189073652488636.38, 189357546861742.44, 189641441234848.47,\n       189925335607954.53,\n       ...\n       269983548823863.56, 270267443196969.62,  270551337570075.7,\n       270835231943181.75,  271119126316287.8, 271403020689393.88,\n       271686915062499.94,  271970809435606.0, 272254703808712.06,\n       272538598181818.12],\n      dtype='float64', name='f', length=301))Attributes: (1)long_name :diffraction amplitude\n\n\n\nprint(dD.medium) \n\noxide\n\n\n\npower = np.array(dD.power[0][0])\n\n\n# plot transmission, compare to paper results, look similar\nfig, ax = plt.subplots(1, 1, figsize=(6, 4.5))\nplt.plot(td.C_0 / fr.freqs(N) * 1000, power / norm_power, \"r\", lw=1, label=\"T\")\nplt.xlabel(r\"wavelength ($nm$)\")\nplt.ylabel(\"Power\")\nplt.ylim(0, 1)\nplt.legend()\nplt.savefig(\"power\", dpi=300)\nplt.show()\n\n\n\namps = np.array(dD.amps[0][0][:,0])\nprint(amps.shape)\n\n(301,)\n\n\n\nimport pandas as pd\n# this uses scienceplots to make plots look better\nplt.style.use(['science', 'notebook', 'grid'])\nprint(pd.DataFrame(amps[0][0]).head())\n\n                                                0                   1\n0 -7.477880e-09-8.372133e-                    10j  0.400083+0.860127j\n1 -7.466276e-09-2.064935e-                    09j  0.385044+0.867238j\n2 -7.082986e-09-3.138136e-                    09j  0.369848+0.874091j\n3 -6.485964e-09-3.902346e-                    09j  0.354497+0.880677j\n4 -5.897012e-09-4.333861e-                    09j  0.339016+0.886985j"
  },
  {
    "objectID": "simulation/diffraction_monitor.slides.html#phase",
    "href": "simulation/diffraction_monitor.slides.html#phase",
    "title": "Diffraction Monitor in Tidy3D",
    "section": "Phase",
    "text": "Phase\n\nphase = np.unwrap(np.angle(amps))\n\n\nnew_amps = batch_data[\"actual\"][\"diffraction_monitor\"].amps\n\n\nmonitor = td.DiffractionMonitor(\n    center=(0, 0, -Lz/2 + spc - (td.C_0 / fr.freq0)),\n    size=(td.inf,td.inf,0),\n    freqs=fr.freqs(N),\n    name='diffraction_monitor',\n    normal_dir='-', # away from structure\n)\n\n\nsims = simulation_helper(\n    background=[polymer],\n    monitors=[monitor],\n    run_time=700 / (fr.fmax - fr.fmin)\n)\n\n\n\n\n\n\n\n\n\nbatch = web.Batch(simulations=sims, verbose=True)\nbatch_data = batch.run(path_dir=\"data/huygens_pol\")\n\n\n\n\n\n\n\n22:17:43 EDT Started working on Batch containing 2 tasks.                       \n\n\n\n22:17:45 EDT Maximum FlexCredit cost: 1.437 for the whole batch.                \n\n\n\n             Use 'Batch.real_cost()' to get the billed FlexCredit cost after the\n             Batch has completed.                                               \n\n\n\n\n\n\n22:18:45 EDT Batch complete.                                                    \n\n\n\n\n\n\n\n\n\n\n\n\n\nfirst_order = batch_data[\"actual\"][\"diffraction_monitor\"].amps[1][1]\nnorm_amps = batch_data[\"norm\"][\"diffraction_monitor\"].amps[1][1]\nphase_p2 = np.unwrap(np.angle(first_order[:, 1]))\nphase_p2 = phase_p2 - phase_p2[0]\nnorm_phase_p2 = np.unwrap(np.angle(norm_amps[:, 1]))\nnorm_phase_p2 = norm_phase_p2 - norm_phase_p2[0]\n\nphase = phase_p2 - norm_phase_p2\n\n\nfig, ax = plt.subplots(1, 1, figsize=(6, 4.5))\nplt.plot(td.C_0 / fr.freqs(N) * 1000, phase, \"r\", lw=1, label=\"$\\phi$\")\nplt.xlabel(r\"wavelength ($nm$)\")\nplt.ylabel(\"Phase\")\nyticks = [0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi]\nytick_labels = [r\"$0$\", r\"$\\frac{\\pi}{2}$\", r\"$\\pi$\", \n                r\"$\\frac{3\\pi}{2}$\", r\"$2\\pi$\"]\nax.set_yticks(yticks)\nax.set_yticklabels(ytick_labels)\nax.legend()\nplt.legend()\nplt.savefig(\"phase.png\", dpi=300)\nplt.show()"
  },
  {
    "objectID": "simulation/diffraction_monitor.html",
    "href": "simulation/diffraction_monitor.html",
    "title": "Diffraction Monitor in Tidy3D",
    "section": "",
    "text": "Here I explored the use of Diffraction Monitor (Documentation) on Huygen’s Metasurface.\n\n# Import the necessary packages\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport tidy3d as td\nimport tidy3d.web as web\nimport scienceplots\n\n# Set logging level to ERROR to reduce output verbosity\ntd.config.logging_level = \"ERROR\"\n\n\n# 0 Define a FreqRange object with desired wavelengths\nfr = td.FreqRange.from_wvl_interval(wvl_min=1.1, wvl_max=1.6)\nN = 301 # num_points\nfreq0 = fr.freq0\nlda0 = td.C_0 / fr.freq0\n\n\n# 1 Computational Domain Size\nh = 0.220  # Height of cylinder\nspc = 2\nLz = spc + h + h + spc\n\nPx = Py = P = 0.666 # periodicity\nsim_size = [Px, Py, Lz]\n\n\n# 2 Grid Resolution\ndl = P / 128\nhorizontal_grid = td.UniformGrid(dl=dl)\nvertical_grid = td.AutoGrid(min_steps_per_wvl=32)\ngrid_spec=td.GridSpec(\n    grid_x=horizontal_grid,\n    grid_y=horizontal_grid,\n    grid_z=vertical_grid,\n)\n\n\nr = 0.242  # radius of the cylinder\nn_Si = 3.5\nSi = td.Medium(permittivity=n_Si**2, name='Si')\ncylinder = td.Structure(\n    geometry=td.Cylinder(center=[0, 0, h / 2], radius=r, length=h, axis=2), medium=Si\n)\n\n# Background medium for the first simulation\nn_glass = 1.4\nn_SiO2 = 1.45\nglass = td.Medium(permittivity=n_glass**2, name='glass')\nSiO2 = td.Medium(permittivity=n_SiO2**2, name='oxide')\n\nsubstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,-Lz/2),\n        size=(td.inf,td.inf,2 * (spc+h))\n    ),\n    medium=SiO2,\n    name='substrate'\n)\n\nglass = td.Structure(\n    geometry=td.Box(\n        center=(0,0,Lz/2),\n        size=(td.inf,td.inf,2 * (spc+h))\n    ),\n    medium=glass,\n    name='superstrate'\n)\n\n# Background medium for the second simulation\n# Polymer\nn_polymer = 1.66\npolymer = td.Structure(\n    geometry=td.Box(\n        center=(0,0,0),\n        size=(td.inf,td.inf,td.inf)\n    ),\n    medium=td.Medium(permittivity=n_polymer**2, name='polymer'),\n    name='polymer'\n)\n\nsource = td.PlaneWave(\n    source_time=fr.to_gaussian_pulse(),\n    size=(td.inf, td.inf, 0),\n    center=(0, 0, Lz/2 - spc + 0.5 * lda0),\n    direction=\"-\",\n    pol_angle=0\n)\n\nmonitor = td.DiffractionMonitor(\n    center=(0, 0, -Lz/2 + spc - 0.5 * lda0),\n    size=(td.inf,td.inf,0),\n    freqs=fr.freqs(N),\n    name='diffraction_monitor',\n    normal_dir='-', # away from structure\n)\n\nbandwidth = fr.fmax - fr.fmin\nrun_time = 200 / bandwidth\n\nbc = td.BoundarySpec(\n    x=td.Boundary.periodic(), \n    y=td.Boundary.periodic(), \n    z=td.Boundary.pml()\n)\n\n\ndef simulation_helper(background, monitors, run_time):\n    \"\"\"\n    Create normalization and actual tidy3d simulations, visualize geometry, \n    and return both as a dictionary.\n\n    Parameters\n    ----------\n    background : list of td.Structure\n        Background structures (without the cylinder).\n    monitors : list of td.Monitor\n        Monitors for the normalization run.\n    run_time : float\n        Run time for the normalization simulation.\n\n    Returns\n    -------\n    dict\n        {\"norm\": Simulation without cylinder,\n         \"actual\": Simulation with cylinder}\n\n    Notes\n    -----\n    Saves cross-sectional plots of the actual simulation (x=0, y=0, z=0) \n    with grid overlay for verification.\n    \"\"\"\n    sim_empty=td.Simulation(\n        size=sim_size,\n        grid_spec=grid_spec,\n        structures=background,\n        sources=[source],\n        monitors=monitors,\n        run_time=run_time,\n        boundary_spec=bc\n    )\n\n    background.append(cylinder)\n    sim_actual = td.Simulation(\n        size=sim_size,\n        grid_spec=grid_spec,\n        structures=background,\n        sources=[source],\n        monitors=monitors,\n        run_time=run_time,\n        boundary_spec=bc\n    )\n\n    # Always visualize simulation before running\n    fig, (ax1,ax2,ax3) = plt.subplots(1, 3, figsize=(12, 6))\n    ax1.tick_params(axis='x', labelsize=7)\n    ax2.tick_params(axis='x', labelsize=7)\n    sim_actual.plot(x=0, ax=ax1)\n    sim_actual.plot_grid(x=0, ax=ax1)\n    sim_actual.plot(y=0, ax=ax2)\n    sim_actual.plot_grid(y=0, ax=ax2)\n    sim_actual.plot(z=0, ax=ax3)\n    sim_actual.plot_grid(z=0, ax=ax3)\n    plt.savefig(f'huygens_structure_{background[0].name}.png', dpi=300)\n    plt.show()\n\n    sims = {\n        \"norm\": sim_empty,\n        \"actual\": sim_actual,\n    }\n\n    return sims\n\n\n\nSimulation\n\nsims = simulation_helper(\n    background=[substrate, glass],\n    monitors=[monitor],\n    run_time=run_time\n)\n\n\n\n\n\n\n\n\n\nbatch = web.Batch(simulations=sims, verbose=True)\nbatch_data = batch.run(path_dir=\"data/huygens_diffraction\")\n\n\n\n\n\n\n\n20:41:03 EDT Started working on Batch containing 2 tasks.                       \n\n\n\n20:41:05 EDT Maximum FlexCredit cost: 0.050 for the whole batch.                \n\n\n\n             Use 'Batch.real_cost()' to get the billed FlexCredit cost after the\n             Batch has completed.                                               \n\n\n\n\n\n\n20:41:16 EDT Batch complete.                                                    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDiffraction Monitor Results\n\ndD = batch_data[\"actual\"][\"diffraction_monitor\"]\nnorm_data = batch_data[\"norm\"][\"diffraction_monitor\"]\n\n# diffraction_data.help()\n\n\ndD.monitor\n\nDiffractionMonitor(attrs={}, type='DiffractionMonitor', center=(0.0, 0.0, -0.8718518518518521), size=(inf, inf, 0.0), name='diffraction_monitor', interval_space=(1, 1, 1), colocate=False, freqs=(187370286250000.0, 187654180623106.06, 187938074996212.12, 188221969369318.2, 188505863742424.25, 188789758115530.3, 189073652488636.38, 189357546861742.44, 189641441234848.47, 189925335607954.53, 190209229981060.6, 190493124354166.66, 190777018727272.72, 191060913100378.78, 191344807473484.84, 191628701846590.9, 191912596219696.97, 192196490592803.03, 192480384965909.1, 192764279339015.16, 193048173712121.22, 193332068085227.28, 193615962458333.34, 193899856831439.38, 194183751204545.44, 194467645577651.5, 194751539950757.56, 195035434323863.62, 195319328696969.7, 195603223070075.75, 195887117443181.8, 196171011816287.88, 196454906189393.94, 196738800562500.0, 197022694935606.06, 197306589308712.12, 197590483681818.2, 197874378054924.25, 198158272428030.3, 198442166801136.34, 198726061174242.4, 199009955547348.47, 199293849920454.53, 199577744293560.6, 199861638666666.66, 200145533039772.72, 200429427412878.78, 200713321785984.84, 200997216159090.9, 201281110532196.97, 201565004905303.03, 201848899278409.1, 202132793651515.16, 202416688024621.2, 202700582397727.25, 202984476770833.3, 203268371143939.38, 203552265517045.44, 203836159890151.5, 204120054263257.56, 204403948636363.62, 204687843009469.7, 204971737382575.75, 205255631755681.8, 205539526128787.88, 205823420501893.94, 206107314875000.0, 206391209248106.06, 206675103621212.12, 206958997994318.16, 207242892367424.22, 207526786740530.28, 207810681113636.34, 208094575486742.4, 208378469859848.47, 208662364232954.53, 208946258606060.6, 209230152979166.66, 209514047352272.72, 209797941725378.78, 210081836098484.84, 210365730471590.9, 210649624844696.94, 210933519217803.0, 211217413590909.06, 211501307964015.12, 211785202337121.2, 212069096710227.25, 212352991083333.3, 212636885456439.38, 212920779829545.44, 213204674202651.5, 213488568575757.56, 213772462948863.62, 214056357321969.7, 214340251695075.75, 214624146068181.8, 214908040441287.88, 215191934814393.94, 215475829187499.97, 215759723560606.03, 216043617933712.1, 216327512306818.16, 216611406679924.22, 216895301053030.28, 217179195426136.34, 217463089799242.4, 217746984172348.47, 218030878545454.53, 218314772918560.6, 218598667291666.66, 218882561664772.72, 219166456037878.75, 219450350410984.8, 219734244784090.88, 220018139157196.94, 220302033530303.0, 220585927903409.06, 220869822276515.12, 221153716649621.2, 221437611022727.25, 221721505395833.3, 222005399768939.38, 222289294142045.44, 222573188515151.5, 222857082888257.56, 223140977261363.62, 223424871634469.7, 223708766007575.75, 223992660380681.8, 224276554753787.84, 224560449126893.9, 224844343499999.97, 225128237873106.03, 225412132246212.1, 225696026619318.16, 225979920992424.22, 226263815365530.28, 226547709738636.34, 226831604111742.4, 227115498484848.47, 227399392857954.53, 227683287231060.56, 227967181604166.62, 228251075977272.7, 228534970350378.75, 228818864723484.8, 229102759096590.88, 229386653469696.94, 229670547842803.0, 229954442215909.06, 230238336589015.12, 230522230962121.2, 230806125335227.25, 231090019708333.3, 231373914081439.38, 231657808454545.44, 231941702827651.5, 232225597200757.56, 232509491573863.62, 232793385946969.7, 233077280320075.72, 233361174693181.78, 233645069066287.84, 233928963439393.9, 234212857812499.97, 234496752185606.03, 234780646558712.1, 235064540931818.16, 235348435304924.22, 235632329678030.28, 235916224051136.34, 236200118424242.38, 236484012797348.44, 236767907170454.5, 237051801543560.56, 237335695916666.62, 237619590289772.7, 237903484662878.75, 238187379035984.8, 238471273409090.88, 238755167782196.94, 239039062155303.0, 239322956528409.06, 239606850901515.12, 239890745274621.2, 240174639647727.25, 240458534020833.3, 240742428393939.38, 241026322767045.44, 241310217140151.5, 241594111513257.53, 241878005886363.6, 242161900259469.66, 242445794632575.72, 242729689005681.78, 243013583378787.84, 243297477751893.9, 243581372124999.97, 243865266498106.03, 244149160871212.1, 244433055244318.16, 244716949617424.2, 245000843990530.25, 245284738363636.3, 245568632736742.38, 245852527109848.44, 246136421482954.5, 246420315856060.56, 246704210229166.62, 246988104602272.7, 247271998975378.75, 247555893348484.8, 247839787721590.88, 248123682094696.94, 248407576467803.0, 248691470840909.06, 248975365214015.12, 249259259587121.2, 249543153960227.25, 249827048333333.3, 250110942706439.34, 250394837079545.4, 250678731452651.47, 250962625825757.53, 251246520198863.6, 251530414571969.66, 251814308945075.72, 252098203318181.78, 252382097691287.84, 252665992064393.9, 252949886437499.97, 253233780810606.0, 253517675183712.06, 253801569556818.12, 254085463929924.2, 254369358303030.25, 254653252676136.3, 254937147049242.38, 255221041422348.44, 255504935795454.5, 255788830168560.56, 256072724541666.62, 256356618914772.7, 256640513287878.75, 256924407660984.8, 257208302034090.88, 257492196407196.94, 257776090780303.0, 258059985153409.06, 258343879526515.12, 258627773899621.2, 258911668272727.25, 259195562645833.28, 259479457018939.34, 259763351392045.4, 260047245765151.47, 260331140138257.53, 260615034511363.6, 260898928884469.66, 261182823257575.7, 261466717630681.75, 261750612003787.8, 262034506376893.88, 262318400749999.94, 262602295123106.0, 262886189496212.06, 263170083869318.12, 263453978242424.2, 263737872615530.25, 264021766988636.3, 264305661361742.38, 264589555734848.44, 264873450107954.5, 265157344481060.56, 265441238854166.62, 265725133227272.7, 266009027600378.75, 266292921973484.8, 266576816346590.88, 266860710719696.94, 267144605092803.0, 267428499465909.06, 267712393839015.1, 267996288212121.16, 268280182585227.22, 268564076958333.28, 268847971331439.34, 269131865704545.4, 269415760077651.47, 269699654450757.5, 269983548823863.56, 270267443196969.62, 270551337570075.7, 270835231943181.75, 271119126316287.8, 271403020689393.88, 271686915062499.94, 271970809435606.0, 272254703808712.06, 272538598181818.12), apodization=ApodizationSpec(attrs={}, start=None, end=None, width=None, type='ApodizationSpec'), normal_dir='-')\n\n\n\ndD.Er\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DiffractionDataArray (orders_x: 1, orders_y: 1, f: 301)&gt; Size: 5kB\narray([[[-0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.-0.j,  0.-0.j,  0.-0.j,\n          0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,\n          0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,\n...\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j]]])\nCoordinates:\n  * orders_x  (orders_x) int64 8B 0\n  * orders_y  (orders_y) int64 8B 0\n  * f         (f) float64 2kB 1.874e+14 1.877e+14 ... 2.723e+14 2.725e+14\nAttributes:\n    long_name:  diffraction amplitudexarray.DiffractionDataArrayorders_x: 1orders_y: 1f: 301(-0-0j) (-0-0j) (-0-0j) (-0-0j) (-0-0j) (-0-0j) ... 0j 0j 0j 0j 0j 0jarray([[[-0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.-0.j,  0.-0.j,  0.-0.j,\n          0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,\n          0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,  0.-0.j,\n...\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j,\n         -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.-0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j, -0.+0.j,\n         -0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,\n          0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j]]])Coordinates: (3)orders_x(orders_x)int640long_name :diffraction orderarray([0])orders_y(orders_y)int640long_name :diffraction orderarray([0])f(f)float641.874e+14 1.877e+14 ... 2.725e+14units :Hzlong_name :frequencyarray([1.873703e+14, 1.876542e+14, 1.879381e+14, ..., 2.719708e+14,\n       2.722547e+14, 2.725386e+14])Indexes: (3)orders_xPandasIndexPandasIndex(Index([0], dtype='int64', name='orders_x'))orders_yPandasIndexPandasIndex(Index([0], dtype='int64', name='orders_y'))fPandasIndexPandasIndex(Index([ 187370286250000.0, 187654180623106.06, 187938074996212.12,\n        188221969369318.2, 188505863742424.25,  188789758115530.3,\n       189073652488636.38, 189357546861742.44, 189641441234848.47,\n       189925335607954.53,\n       ...\n       269983548823863.56, 270267443196969.62,  270551337570075.7,\n       270835231943181.75,  271119126316287.8, 271403020689393.88,\n       271686915062499.94,  271970809435606.0, 272254703808712.06,\n       272538598181818.12],\n      dtype='float64', name='f', length=301))Attributes: (1)long_name :diffraction amplitude\n\n\n\nprint(dD.medium) \n\noxide\n\n\n\npower = np.array(dD.power[0][0])\n\n\n# plot transmission, compare to paper results, look similar\nfig, ax = plt.subplots(1, 1, figsize=(6, 4.5))\nplt.plot(td.C_0 / fr.freqs(N) * 1000, power / norm_power, \"r\", lw=1, label=\"T\")\nplt.xlabel(r\"wavelength ($nm$)\")\nplt.ylabel(\"Power\")\nplt.ylim(0, 1)\nplt.legend()\nplt.savefig(\"power\", dpi=300)\nplt.show()\n\n\n\n\n\n\n\n\n\namps = np.array(dD.amps[0][0][:,0])\nprint(amps.shape)\n\n(301,)\n\n\n\nimport pandas as pd\n# this uses scienceplots to make plots look better\nplt.style.use(['science', 'notebook', 'grid'])\nprint(pd.DataFrame(amps[0][0]).head())\n\n                                                0                   1\n0 -7.477880e-09-8.372133e-                    10j  0.400083+0.860127j\n1 -7.466276e-09-2.064935e-                    09j  0.385044+0.867238j\n2 -7.082986e-09-3.138136e-                    09j  0.369848+0.874091j\n3 -6.485964e-09-3.902346e-                    09j  0.354497+0.880677j\n4 -5.897012e-09-4.333861e-                    09j  0.339016+0.886985j\n\n\n\n\nPhase\n\nphase = np.unwrap(np.angle(amps))\n\n\nnew_amps = batch_data[\"actual\"][\"diffraction_monitor\"].amps\n\n\nmonitor = td.DiffractionMonitor(\n    center=(0, 0, -Lz/2 + spc - (td.C_0 / fr.freq0)),\n    size=(td.inf,td.inf,0),\n    freqs=fr.freqs(N),\n    name='diffraction_monitor',\n    normal_dir='-', # away from structure\n)\n\n\nsims = simulation_helper(\n    background=[polymer],\n    monitors=[monitor],\n    run_time=700 / (fr.fmax - fr.fmin)\n)\n\n\n\n\n\n\n\n\n\nbatch = web.Batch(simulations=sims, verbose=True)\nbatch_data = batch.run(path_dir=\"data/huygens_pol\")\n\n\n\n\n\n\n\n22:17:43 EDT Started working on Batch containing 2 tasks.                       \n\n\n\n22:17:45 EDT Maximum FlexCredit cost: 1.437 for the whole batch.                \n\n\n\n             Use 'Batch.real_cost()' to get the billed FlexCredit cost after the\n             Batch has completed.                                               \n\n\n\n\n\n\n22:18:45 EDT Batch complete.                                                    \n\n\n\n\n\n\n\n\n\n\n\n\n\nfirst_order = batch_data[\"actual\"][\"diffraction_monitor\"].amps[1][1]\nnorm_amps = batch_data[\"norm\"][\"diffraction_monitor\"].amps[1][1]\nphase_p2 = np.unwrap(np.angle(first_order[:, 1]))\nphase_p2 = phase_p2 - phase_p2[0]\nnorm_phase_p2 = np.unwrap(np.angle(norm_amps[:, 1]))\nnorm_phase_p2 = norm_phase_p2 - norm_phase_p2[0]\n\nphase = phase_p2 - norm_phase_p2\n\n\nfig, ax = plt.subplots(1, 1, figsize=(6, 4.5))\nplt.plot(td.C_0 / fr.freqs(N) * 1000, phase, \"r\", lw=1, label=\"$\\phi$\")\nplt.xlabel(r\"wavelength ($nm$)\")\nplt.ylabel(\"Phase\")\nyticks = [0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi]\nytick_labels = [r\"$0$\", r\"$\\frac{\\pi}{2}$\", r\"$\\pi$\", \n                r\"$\\frac{3\\pi}{2}$\", r\"$2\\pi$\"]\nax.set_yticks(yticks)\nax.set_yticklabels(ytick_labels)\nax.legend()\nplt.legend()\nplt.savefig(\"phase.png\", dpi=300)\nplt.show()",
    "crumbs": [
      "Python",
      "Diffraction Monitor in Tidy3D"
    ]
  },
  {
    "objectID": "simulation/huygens.slides.html#simulation-overview",
    "href": "simulation/huygens.slides.html#simulation-overview",
    "title": "Huygens’ Surfaces",
    "section": "Simulation Overview",
    "text": "Simulation Overview\n\n# Import the necessary packages\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport tidy3d as td\nimport tidy3d.web as web\nimport scienceplots\n\n# Set logging level to ERROR to reduce output verbosity\ntd.config.logging_level = \"ERROR\"\n\n\nFor the transmittance and phase, two different background materials were used based in the paper, so two separate simulations were ran (with background medium as the only difference).\n\nNote: Several other technical variables need to be changed. In tidy3D simulation, transmittance should be measured with td.FluxMonitor and phase should be measured with td.FieldMonitor. The run_time also needs to increase since the background medium has a higher refractive index in the second simulation than the first, so waves will travel more slowly."
  },
  {
    "objectID": "simulation/huygens.slides.html#initialization",
    "href": "simulation/huygens.slides.html#initialization",
    "title": "Huygens’ Surfaces",
    "section": "Initialization",
    "text": "Initialization\nHere we follow the seven steps of initialization I wrote down in the tutorial:\n\nFrequency Range Specification\nComputational Domain Size\nGrid Specifications (Discretization size)\nStructures and Materials\nSources\nMonitors\nRun time\nBoundary Condition Specification"
  },
  {
    "objectID": "simulation/huygens.slides.html#frequency-range-specification",
    "href": "simulation/huygens.slides.html#frequency-range-specification",
    "title": "Huygens’ Surfaces",
    "section": "0 Frequency Range Specification",
    "text": "0 Frequency Range Specification\n\n# 0 Define a FreqRange object with desired wavelengths\nfr = td.FreqRange.from_wvl_interval(wvl_min=1.1, wvl_max=1.6)\nN = 301 # num_points\nfreq0 = fr.freq0\nlda0 = td.C_0 / fr.freq0"
  },
  {
    "objectID": "simulation/huygens.slides.html#computational-domain-size",
    "href": "simulation/huygens.slides.html#computational-domain-size",
    "title": "Huygens’ Surfaces",
    "section": "1 Computational Domain Size",
    "text": "1 Computational Domain Size\n\n# 1 Computational Domain Size\nh = 0.220  # Height of cylinder\nspc = 2\nLz = spc + h + h + spc\n\nPx = Py = P = 0.666 # periodicity\nsim_size = [Px, Py, Lz]"
  },
  {
    "objectID": "simulation/huygens.slides.html#grid-resolution",
    "href": "simulation/huygens.slides.html#grid-resolution",
    "title": "Huygens’ Surfaces",
    "section": "2 Grid Resolution",
    "text": "2 Grid Resolution\nGrid resolution is uniform grid in the horizontal direction with a yee cell length of \\frac{P}{32} where P is the periodicity. In the vertical direction, AutoGrid means it’s non-uniform and adjusted based on the wavelength of the particular medium. Here, min_steps_per_wvl=32 means we are taking a minimum of 32 steps based on the wavelength, which will be shorter in the medium with a higher index of refraction.\n\n# 2 Grid Resolution\ndl = P / 32\nhorizontal_grid = td.UniformGrid(dl=dl)\nvertical_grid = td.AutoGrid(min_steps_per_wvl=32)\ngrid_spec=td.GridSpec(\n    grid_x=horizontal_grid,\n    grid_y=horizontal_grid,\n    grid_z=vertical_grid,\n)"
  },
  {
    "objectID": "simulation/huygens.slides.html#structures-and-materials",
    "href": "simulation/huygens.slides.html#structures-and-materials",
    "title": "Huygens’ Surfaces",
    "section": "3 Structures and Materials",
    "text": "3 Structures and Materials\nStructures and Materials for the meta-atom\n\nr = 0.242  # radius of the cylinder\nn_Si = 3.5\nSi = td.Medium(permittivity=n_Si**2, name='Si')\ncylinder = td.Structure(\n    geometry=td.Cylinder(center=[0, 0, h / 2], radius=r, length=h, axis=2), medium=Si\n)\n\nBackground Medium for Figure 5(a) (n_1=1.4, n_2=1.45)\n\n# Background medium for the first simulation\nn_glass = 1.4\nn_SiO2 = 1.45\nglass = td.Medium(permittivity=n_glass**2, name='glass')\nSiO2 = td.Medium(permittivity=n_SiO2**2, name='oxide')\n\nsubstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,-Lz/2),\n        size=(td.inf,td.inf,2 * (spc+h))\n    ),\n    medium=SiO2,\n    name='substrate'\n)\n\nglass = td.Structure(\n    geometry=td.Box(\n        center=(0,0,Lz/2),\n        size=(td.inf,td.inf,2 * (spc+h))\n    ),\n    medium=glass,\n    name='superstrate'\n)"
  },
  {
    "objectID": "simulation/huygens.slides.html#the-source",
    "href": "simulation/huygens.slides.html#the-source",
    "title": "Huygens’ Surfaces",
    "section": "4 The Source",
    "text": "4 The Source\nThe source is a simple Plane wave that traverses in the -z axis, placed \\frac{\\lambda_0}{2} distance above the metaatom in the computational domain. Polarization is along the x-axis, that’s what pol_angle=0 means.\n\nsource = td.PlaneWave(\n    source_time=fr.to_gaussian_pulse(),\n    size=(td.inf, td.inf, 0),\n    center=(0, 0, Lz/2 - spc + 0.5 * lda0),\n    direction=\"-\",\n    pol_angle=0\n)"
  },
  {
    "objectID": "simulation/huygens.slides.html#monitors",
    "href": "simulation/huygens.slides.html#monitors",
    "title": "Huygens’ Surfaces",
    "section": "5 Monitors",
    "text": "5 Monitors\nMonitor for Transmittance\n\nflux_monitor = td.FluxMonitor(\n    center=(0, 0, -Lz/2 + spc - 0.5 * lda0),\n    size=(td.inf, td.inf, 0),\n    freqs=fr.freqs(N),\n    name=\"flux_monitor\"\n)\n\nMonitor for Phase\n\n# We use FieldMonitor instead of DiffractionMonitor because\n# DiffractionMonitor only gives you amplitudes of diffraction orders, \n# losing phase detail if you care about continuous phase.\nfield_monitor = td.FieldMonitor(\n    center=(0, 0, -Lz/2 + spc - 0.5 * lda0),\n    size=(td.inf, td.inf, 0),\n    fields=[\"Ex\"],\n    freqs=fr.freqs(N),\n    name=\"field_monitor\"\n)"
  },
  {
    "objectID": "simulation/huygens.slides.html#run-time",
    "href": "simulation/huygens.slides.html#run-time",
    "title": "Huygens’ Surfaces",
    "section": "6 Run Time",
    "text": "6 Run Time\n\nbandwidth = fr.fmax - fr.fmin\nrun_time_short = 50 / bandwidth # run_time for the transmittance simulation\nrun_time_long = 200 / bandwidth # run_time for the phase simulation"
  },
  {
    "objectID": "simulation/huygens.slides.html#boundary-conditions",
    "href": "simulation/huygens.slides.html#boundary-conditions",
    "title": "Huygens’ Surfaces",
    "section": "7 Boundary Conditions",
    "text": "7 Boundary Conditions\nWe apply PML in the +Z and -Z surfaces.\n\nbc = td.BoundarySpec(\n    x=td.Boundary.periodic(), \n    y=td.Boundary.periodic(), \n    z=td.Boundary.pml()\n)"
  },
  {
    "objectID": "simulation/huygens.slides.html#helper-function-for-simulation",
    "href": "simulation/huygens.slides.html#helper-function-for-simulation",
    "title": "Huygens’ Surfaces",
    "section": "Helper Function for simulation",
    "text": "Helper Function for simulation\nSince we have to run simulation two times, it is convenient to abstract out what are the differences to the two simulations and make defining simulations easier. Always follow the DRY Principle.\n\ndef simulation_helper(background, monitors, run_time):\n    sim_empty=td.Simulation(\n        size=sim_size,\n        grid_spec=grid_spec,\n        structures=background,\n        sources=[source],\n        monitors=monitors,\n        run_time=run_time,\n        boundary_spec=bc\n    )\n\n    background.append(cylinder)\n    sim_actual = td.Simulation(\n        size=sim_size,\n        grid_spec=grid_spec,\n        structures=background,\n        sources=[source],\n        monitors=monitors,\n        run_time=run_time,\n        boundary_spec=bc\n    )\n\n    # Always visualize simulation before running\n    fig, (ax1,ax2,ax3) = plt.subplots(1, 3, figsize=(12, 6))\n    ax1.tick_params(axis='x', labelsize=7)\n    ax2.tick_params(axis='x', labelsize=7)\n    sim_actual.plot(x=0, ax=ax1)\n    sim_actual.plot_grid(x=0, ax=ax1)\n    sim_actual.plot(y=0, ax=ax2)\n    sim_actual.plot_grid(y=0, ax=ax2)\n    sim_actual.plot(z=0, ax=ax3)\n    sim_actual.plot_grid(z=0, ax=ax3)\n    plt.savefig(f'huygens_structure_{background[0].name}.png', dpi=300)\n    plt.show()\n\n    sims = {\n        \"norm\": sim_empty,\n        \"actual\": sim_actual,\n    }\n\n    return sims"
  },
  {
    "objectID": "simulation/huygens.slides.html#transmittance-simulation",
    "href": "simulation/huygens.slides.html#transmittance-simulation",
    "title": "Huygens’ Surfaces",
    "section": "Transmittance Simulation",
    "text": "Transmittance Simulation\n\nsims = simulation_helper(\n    background=[substrate, glass],\n    monitors=[flux_monitor],\n    run_time=run_time_short\n)\n\n\n\nbatch = web.Batch(simulations=sims, verbose=True)\nbatch_data = batch.run(path_dir=\"data/huygens5a\")\n\n\n\n\n\n\n\n02:20:56 EDT Started working on Batch containing 2 tasks.                       \n\n\n\n02:20:57 EDT Maximum FlexCredit cost: 0.050 for the whole batch.                \n\n\n\n             Use 'Batch.real_cost()' to get the billed FlexCredit cost after the\n             Batch has completed.                                               \n\n\n\n\n\n\n02:20:58 EDT Batch complete."
  },
  {
    "objectID": "simulation/huygens.slides.html#transmittance-results",
    "href": "simulation/huygens.slides.html#transmittance-results",
    "title": "Huygens’ Surfaces",
    "section": "Transmittance Results",
    "text": "Transmittance Results\n\n# this uses scienceplots to make plots look better\nplt.style.use(['science', 'notebook', 'grid'])\nT = batch_data[\"actual\"][\"flux_monitor\"].flux / batch_data[\"norm\"][\"flux_monitor\"].flux\n\n\n# plot transmission, compare to paper results, look similar\nfig, ax = plt.subplots(1, 1, figsize=(6, 4.5))\nplt.plot(td.C_0 / fr.freqs(N) * 1000, np.abs(T)**2, \"r\", lw=1, label=\"T\")\nplt.xlabel(r\"wavelength ($nm$)\")\nplt.ylabel(\"Transmittance\")\nplt.ylim(0, 1)\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "simulation/huygens.slides.html#phase-simulation",
    "href": "simulation/huygens.slides.html#phase-simulation",
    "title": "Huygens’ Surfaces",
    "section": "Phase Simulation",
    "text": "Phase Simulation\n\nsims = simulation_helper(\n    background=[polymer],\n    monitors=[field_monitor],\n    run_time=run_time_long\n)\n\n\n\nbatch = web.Batch(simulations=sims, verbose=True)\nbatch_data = batch.run(path_dir=\"data/huygens5c\")\n\n\n\n\n\n\n\n02:21:11 EDT Started working on Batch containing 2 tasks.                       \n\n\n\n02:21:13 EDT Maximum FlexCredit cost: 0.050 for the whole batch.                \n\n\n\n             Use 'Batch.real_cost()' to get the billed FlexCredit cost after the\n             Batch has completed.                                               \n\n\n\n\n\n\n02:21:14 EDT Batch complete."
  },
  {
    "objectID": "simulation/huygens.slides.html#phase-results",
    "href": "simulation/huygens.slides.html#phase-results",
    "title": "Huygens’ Surfaces",
    "section": "Phase Results",
    "text": "Phase Results\n\n# Data Extraction\nEx_actual = batch_data[\"actual\"][\"field_monitor\"].Ex \nEx_norm = batch_data[\"norm\"][\"field_monitor\"].Ex\nEx = Ex_actual / Ex_norm\n\n\n# 1. Compute average over the xy-plane\nEx_avg = np.mean(Ex[:, :, 0, :], axis=(0,1))\n\n# 2. Compute phase\nphase_avg = np.angle(Ex_avg)\n\n# 3. Unwrap phase to remove ±pi jumps\nphase_avg_unwrapped = np.unwrap(phase_avg)\n\n# 4. Make relative to first point (optional)\nphase_rel = phase_avg_unwrapped - phase_avg_unwrapped[0]\n\nphase_actual = np.unwrap(np.angle(np.mean(Ex_actual[:, :, 0, :], axis=(0,1))))\nphase_norm = np.unwrap(np.angle(np.mean(Ex_norm[:, :, 0, :], axis=(0,1))))\n\n\nfig, ax = plt.subplots(1, 1, figsize=(6, 4.5))\nplt.plot(td.C_0 / fr.freqs(N) * 1000, phase_rel, \"r\", lw=1, label=\"$\\phi$\")\nplt.plot(td.C_0 / fr.freqs(N) * 1000, phase_actual, \"b\", lw=1, label=\"Actual $\\phi$\")\nplt.plot(td.C_0 / fr.freqs(N) * 1000, phase_norm, \"g\", lw=1, label=\"Norm $\\phi$\")\nplt.xlabel(r\"wavelength ($nm$)\")\nplt.ylabel(\"Phase\")\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "simulation/huygens.slides.html#final-plotting",
    "href": "simulation/huygens.slides.html#final-plotting",
    "title": "Huygens’ Surfaces",
    "section": "Final Plotting",
    "text": "Final Plotting\n\nfig, axes = plt.subplots(1, 2, figsize=(12, 4))\n\n# work on the first figure\nax = axes[0]\nax.tick_params(axis=\"both\", labelsize=10)\nax.plot(td.C_0 / fr.freqs(N) * 1000, np.abs(T)**2, \"r\", lw=1, label=\"$|T|^2$\")\nax.set_xlabel(r\"wavelength [$nm$]\", fontsize=12)\nax.set_ylabel(\"Transmittance\", fontsize=12)\nax.set_title(\"Transmittance vs Wavelength from Simulation 1\", fontsize=12)\nax.set_xlim(1100, 1600)\nax.set_ylim(0, 1.1)\nax.legend(loc=\"lower right\", fontsize=12)\n\n# work on the second figure\nax = axes[1]\nax.tick_params(axis=\"both\", labelsize=10)\nax.plot(td.C_0 / fr.freqs(N) * 1000, phase_rel, \"b\", lw=1, label=\"$\\phi$\")\nax.set_xlabel(r\"wavelength [$nm$]\", fontsize=12)\nax.set_ylabel(\"Phase [rad]\", fontsize=12)\nax.set_title(\"Phase Change vs Wavelength from Simulation 2\", fontsize=12)\nax.set_xlim(1100, 1600)\nax.set_ylim(0, np.pi*2)\nyticks = [0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi]\nytick_labels = [r\"$0$\", r\"$\\frac{\\pi}{2}$\", r\"$\\pi$\", \n                r\"$\\frac{3\\pi}{2}$\", r\"$2\\pi$\"]\nax.set_yticks(yticks)\nax.set_yticklabels(ytick_labels)\nax.legend()\n\nplt.savefig(\"huygens.png\", dpi=300)"
  },
  {
    "objectID": "simulation/huygens.slides.html#mesh-study",
    "href": "simulation/huygens.slides.html#mesh-study",
    "title": "Huygens’ Surfaces",
    "section": "Mesh Study",
    "text": "Mesh Study\nHere, we set out to study the effect of different yee cell length on the transmittance.\n\ndls = [P/2, P/4, P/8, P/16, P/32, P/64, P/128] # mesh study list\nsims = {}\n\n\n# for each dl in dls\nfor i, dl in enumerate(dls):\n    # 2 Grid Specifications\n    horizontal_grid = td.UniformGrid(dl=dl)\n    vertical_grid = td.AutoGrid(min_steps_per_wvl=32)\n    grid_spec=td.GridSpec(\n        grid_x=horizontal_grid,\n        grid_y=horizontal_grid,\n        grid_z=vertical_grid,\n    )\n\n    # 4 Sources\n    source = td.PlaneWave(\n        source_time=fr.to_gaussian_pulse(),\n        size=(td.inf, td.inf, 0),\n        center=(0, 0, Lz/2 - spc + 2 * dl),\n        direction=\"-\",\n        pol_angle=0\n    )\n\n    # 5 Monitor\n    monitor = td.FluxMonitor(\n        center=(0, 0, -Lz/2 + spc - 2*dl),\n        size=(td.inf, td.inf, 0),\n        freqs=fr.freqs(N),\n        name=\"flux\"\n    )\n\n    sim_empty=td.Simulation(\n        size=sim_size,\n        grid_spec=grid_spec,\n        structures=[substrate, glass],\n        sources=[source],\n        monitors=[monitor],\n        run_time=run_time_short,\n        boundary_spec=bc\n    )\n\n    sim_actual = td.Simulation(\n        size=sim_size,\n        grid_spec=grid_spec,\n        structures=[substrate, glass, cylinder],\n        sources=[source],\n        monitors=[monitor],\n        run_time=run_time_short,\n        boundary_spec=bc\n    )\n\n    sims[f\"norm{i}\"] = sim_empty\n    sims[f\"actual{i}\"] = sim_actual  \n\n\n# verify the sims dictionary\nprint(sims.keys())\nbatch = web.Batch(simulations=sims, verbose=True)\n\ndict_keys(['norm0', 'actual0', 'norm1', 'actual1', 'norm2', 'actual2', 'norm3', 'actual3', 'norm4', 'actual4', 'norm5', 'actual5', 'norm6', 'actual6'])\n\n\n\n# run the simulations\nbatch_data = batch.run(path_dir=\"data\")\n\n\n\n\n\n\n\n02:21:47 EDT Started working on Batch containing 14 tasks.                      \n\n\n\n02:21:59 EDT Maximum FlexCredit cost: 0.392 for the whole batch.                \n\n\n\n             Use 'Batch.real_cost()' to get the billed FlexCredit cost after the\n             Batch has completed.                                               \n\n\n\n\n\n\n02:22:21 EDT Batch complete."
  },
  {
    "objectID": "simulation/huygens.slides.html#mesh-study-results",
    "href": "simulation/huygens.slides.html#mesh-study-results",
    "title": "Huygens’ Surfaces",
    "section": "Mesh Study Results",
    "text": "Mesh Study Results\n\n# Extract results\nx = td.C_0 / fr.freqs(N) * 1000\nTs = []\nfor i in range(len(dls)):\n    Ts.append(batch_data[f\"actual{i}\"][\"flux\"].flux / batch_data[f\"norm{i}\"][\"flux\"].flux)\n\n\n# Plot results\nplt.figure(figsize=(10, 5))\nfor i, T in enumerate(Ts):\n    plt.plot(x, np.abs(T)**2, \"-\",lw=1, label=f\"dl={dls[i] * 1000:.1f} nm\")\nplt.xlabel(r\"Wavelength [$nm$]\", fontsize=12)\nplt.ylabel(r\"$|T|^2$\", fontsize=12)\nplt.xlim(1100, 1600)\nplt.ylim(-0.1, 1.1)\nplt.legend(fontsize=12)\nplt.tick_params(axis='both', labelsize=10) # change tick label size to 10\nplt.title(\"Transmission Spectra with Different Mesh Sizes\", fontsize=14)\nplt.savefig(\"mesh_convergence.png\", dpi=300)\nplt.show()"
  },
  {
    "objectID": "simulation/huygens.html",
    "href": "simulation/huygens.html",
    "title": "Huygens’ Surfaces",
    "section": "",
    "text": "Figure 1: Huygens Metasurface\n\n\n\n\n\nIn this notebook, the Huygens’ Metasurface figure 5(a) and 5(c) are reproduced, and mesh study is done for the transmittance. Link to Paper\n\nSimulation Overview\n\n# Import the necessary packages\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport tidy3d as td\nimport tidy3d.web as web\nimport scienceplots\n\n# Set logging level to ERROR to reduce output verbosity\ntd.config.logging_level = \"ERROR\"\n\n\nFor the transmittance and phase, two different background materials were used based in the paper, so two separate simulations were ran (with background medium as the only difference).\n\nNote: Several other technical variables need to be changed. In tidy3D simulation, transmittance should be measured with td.FluxMonitor and phase should be measured with td.FieldMonitor. The run_time also needs to increase since the background medium has a higher refractive index in the second simulation than the first, so waves will travel more slowly.\n\nSimulation 1\n\n\n\nTop Layer n=1.4, Bottom Layer n=1.45\n\n\n\nSimulation 2\n\n\n\nBackground medium n=1.66\n\n\n\nSimulation Results\n\n\nMesh Study Results\n\n\n\nConvergence of Transmittance\n\n\n\n\n\nInitialization\nHere we follow the seven steps of initialization I wrote down in the tutorial:\n\nFrequency Range Specification\nComputational Domain Size\nGrid Specifications (Discretization size)\nStructures and Materials\nSources\nMonitors\nRun time\nBoundary Condition Specification\n\n\n\n0 Frequency Range Specification\n\n# 0 Define a FreqRange object with desired wavelengths\nfr = td.FreqRange.from_wvl_interval(wvl_min=1.1, wvl_max=1.6)\nN = 301 # num_points\nfreq0 = fr.freq0\nlda0 = td.C_0 / fr.freq0\n\n\n\n1 Computational Domain Size\n\n# 1 Computational Domain Size\nh = 0.220  # Height of cylinder\nspc = 2\nLz = spc + h + h + spc\n\nPx = Py = P = 0.666 # periodicity\nsim_size = [Px, Py, Lz]\n\n\n\n2 Grid Resolution\nGrid resolution is uniform grid in the horizontal direction with a yee cell length of \\frac{P}{32} where P is the periodicity. In the vertical direction, AutoGrid means it’s non-uniform and adjusted based on the wavelength of the particular medium. Here, min_steps_per_wvl=32 means we are taking a minimum of 32 steps based on the wavelength, which will be shorter in the medium with a higher index of refraction.\n\n# 2 Grid Resolution\ndl = P / 32\nhorizontal_grid = td.UniformGrid(dl=dl)\nvertical_grid = td.AutoGrid(min_steps_per_wvl=32)\ngrid_spec=td.GridSpec(\n    grid_x=horizontal_grid,\n    grid_y=horizontal_grid,\n    grid_z=vertical_grid,\n)\n\n\n\n3 Structures and Materials\nStructures and Materials for the meta-atom\n\nr = 0.242  # radius of the cylinder\nn_Si = 3.5\nSi = td.Medium(permittivity=n_Si**2, name='Si')\ncylinder = td.Structure(\n    geometry=td.Cylinder(center=[0, 0, h / 2], radius=r, length=h, axis=2), medium=Si\n)\n\nBackground Medium for Figure 5(a) (n_1=1.4, n_2=1.45)\n\n# Background medium for the first simulation\nn_glass = 1.4\nn_SiO2 = 1.45\nglass = td.Medium(permittivity=n_glass**2, name='glass')\nSiO2 = td.Medium(permittivity=n_SiO2**2, name='oxide')\n\nsubstrate = td.Structure(\n    geometry=td.Box(\n        center=(0,0,-Lz/2),\n        size=(td.inf,td.inf,2 * (spc+h))\n    ),\n    medium=SiO2,\n    name='substrate'\n)\n\nglass = td.Structure(\n    geometry=td.Box(\n        center=(0,0,Lz/2),\n        size=(td.inf,td.inf,2 * (spc+h))\n    ),\n    medium=glass,\n    name='superstrate'\n)\n\n\nBackground Medium for Figure 5(c) (n=1.66)\n\n# Background medium for the second simulation\n# Polymer\nn_polymer = 1.66\npolymer = td.Structure(\n    geometry=td.Box(\n        center=(0,0,0),\n        size=(td.inf,td.inf,td.inf)\n    ),\n    medium=td.Medium(permittivity=n_polymer**2, name='polymer'),\n    name='polymer'\n)\n\n\n\n4 The Source\nThe source is a simple Plane wave that traverses in the -z axis, placed \\frac{\\lambda_0}{2} distance above the metaatom in the computational domain. Polarization is along the x-axis, that’s what pol_angle=0 means.\n\nsource = td.PlaneWave(\n    source_time=fr.to_gaussian_pulse(),\n    size=(td.inf, td.inf, 0),\n    center=(0, 0, Lz/2 - spc + 0.5 * lda0),\n    direction=\"-\",\n    pol_angle=0\n)\n\n\n\n5 Monitors\nMonitor for Transmittance\n\nflux_monitor = td.FluxMonitor(\n    center=(0, 0, -Lz/2 + spc - 0.5 * lda0),\n    size=(td.inf, td.inf, 0),\n    freqs=fr.freqs(N),\n    name=\"flux_monitor\"\n)\n\nMonitor for Phase\n\n# We use FieldMonitor instead of DiffractionMonitor because\n# DiffractionMonitor only gives you amplitudes of diffraction orders, \n# losing phase detail if you care about continuous phase.\nfield_monitor = td.FieldMonitor(\n    center=(0, 0, -Lz/2 + spc - 0.5 * lda0),\n    size=(td.inf, td.inf, 0),\n    fields=[\"Ex\"],\n    freqs=fr.freqs(N),\n    name=\"field_monitor\"\n)\n\n\n\n6 Run Time\n\nbandwidth = fr.fmax - fr.fmin\nrun_time_short = 50 / bandwidth # run_time for the transmittance simulation\nrun_time_long = 200 / bandwidth # run_time for the phase simulation\n\n\n\n7 Boundary Conditions\nWe apply PML in the +Z and -Z surfaces.\n\nbc = td.BoundarySpec(\n    x=td.Boundary.periodic(), \n    y=td.Boundary.periodic(), \n    z=td.Boundary.pml()\n)\n\n\n\nHelper Function for simulation\nSince we have to run simulation two times, it is convenient to abstract out what are the differences to the two simulations and make defining simulations easier. Always follow the DRY Principle.\n\ndef simulation_helper(background, monitors, run_time):\n    sim_empty=td.Simulation(\n        size=sim_size,\n        grid_spec=grid_spec,\n        structures=background,\n        sources=[source],\n        monitors=monitors,\n        run_time=run_time,\n        boundary_spec=bc\n    )\n\n    background.append(cylinder)\n    sim_actual = td.Simulation(\n        size=sim_size,\n        grid_spec=grid_spec,\n        structures=background,\n        sources=[source],\n        monitors=monitors,\n        run_time=run_time,\n        boundary_spec=bc\n    )\n\n    # Always visualize simulation before running\n    fig, (ax1,ax2,ax3) = plt.subplots(1, 3, figsize=(12, 6))\n    ax1.tick_params(axis='x', labelsize=7)\n    ax2.tick_params(axis='x', labelsize=7)\n    sim_actual.plot(x=0, ax=ax1)\n    sim_actual.plot_grid(x=0, ax=ax1)\n    sim_actual.plot(y=0, ax=ax2)\n    sim_actual.plot_grid(y=0, ax=ax2)\n    sim_actual.plot(z=0, ax=ax3)\n    sim_actual.plot_grid(z=0, ax=ax3)\n    plt.savefig(f'huygens_structure_{background[0].name}.png', dpi=300)\n    plt.show()\n\n    sims = {\n        \"norm\": sim_empty,\n        \"actual\": sim_actual,\n    }\n\n    return sims\n\n\n\n\nTransmittance Simulation\n\nsims = simulation_helper(\n    background=[substrate, glass],\n    monitors=[flux_monitor],\n    run_time=run_time_short\n)\n\n\n\n\n\n\n\n\n\nbatch = web.Batch(simulations=sims, verbose=True)\nbatch_data = batch.run(path_dir=\"data/huygens5a\")\n\n\n\n\n\n\n\n02:20:56 EDT Started working on Batch containing 2 tasks.                       \n\n\n\n02:20:57 EDT Maximum FlexCredit cost: 0.050 for the whole batch.                \n\n\n\n             Use 'Batch.real_cost()' to get the billed FlexCredit cost after the\n             Batch has completed.                                               \n\n\n\n\n\n\n02:20:58 EDT Batch complete.                                                    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTransmittance Results\n\n# this uses scienceplots to make plots look better\nplt.style.use(['science', 'notebook', 'grid'])\nT = batch_data[\"actual\"][\"flux_monitor\"].flux / batch_data[\"norm\"][\"flux_monitor\"].flux\n\n\n# plot transmission, compare to paper results, look similar\nfig, ax = plt.subplots(1, 1, figsize=(6, 4.5))\nplt.plot(td.C_0 / fr.freqs(N) * 1000, np.abs(T)**2, \"r\", lw=1, label=\"T\")\nplt.xlabel(r\"wavelength ($nm$)\")\nplt.ylabel(\"Transmittance\")\nplt.ylim(0, 1)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nPhase Simulation\n\nsims = simulation_helper(\n    background=[polymer],\n    monitors=[field_monitor],\n    run_time=run_time_long\n)\n\n\n\n\n\n\n\n\n\nbatch = web.Batch(simulations=sims, verbose=True)\nbatch_data = batch.run(path_dir=\"data/huygens5c\")\n\n\n\n\n\n\n\n02:21:11 EDT Started working on Batch containing 2 tasks.                       \n\n\n\n02:21:13 EDT Maximum FlexCredit cost: 0.050 for the whole batch.                \n\n\n\n             Use 'Batch.real_cost()' to get the billed FlexCredit cost after the\n             Batch has completed.                                               \n\n\n\n\n\n\n02:21:14 EDT Batch complete.                                                    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPhase Results\n\n# Data Extraction\nEx_actual = batch_data[\"actual\"][\"field_monitor\"].Ex \nEx_norm = batch_data[\"norm\"][\"field_monitor\"].Ex\nEx = Ex_actual / Ex_norm\n\n\n# 1. Compute average over the xy-plane\nEx_avg = np.mean(Ex[:, :, 0, :], axis=(0,1))\n\n# 2. Compute phase\nphase_avg = np.angle(Ex_avg)\n\n# 3. Unwrap phase to remove ±pi jumps\nphase_avg_unwrapped = np.unwrap(phase_avg)\n\n# 4. Make relative to first point (optional)\nphase_rel = phase_avg_unwrapped - phase_avg_unwrapped[0]\n\nphase_actual = np.unwrap(np.angle(np.mean(Ex_actual[:, :, 0, :], axis=(0,1))))\nphase_norm = np.unwrap(np.angle(np.mean(Ex_norm[:, :, 0, :], axis=(0,1))))\n\n\nfig, ax = plt.subplots(1, 1, figsize=(6, 4.5))\nplt.plot(td.C_0 / fr.freqs(N) * 1000, phase_rel, \"r\", lw=1, label=\"$\\phi$\")\nplt.plot(td.C_0 / fr.freqs(N) * 1000, phase_actual, \"b\", lw=1, label=\"Actual $\\phi$\")\nplt.plot(td.C_0 / fr.freqs(N) * 1000, phase_norm, \"g\", lw=1, label=\"Norm $\\phi$\")\nplt.xlabel(r\"wavelength ($nm$)\")\nplt.ylabel(\"Phase\")\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nFinal Plotting\n\nfig, axes = plt.subplots(1, 2, figsize=(12, 4))\n\n# work on the first figure\nax = axes[0]\nax.tick_params(axis=\"both\", labelsize=10)\nax.plot(td.C_0 / fr.freqs(N) * 1000, np.abs(T)**2, \"r\", lw=1, label=\"$|T|^2$\")\nax.set_xlabel(r\"wavelength [$nm$]\", fontsize=12)\nax.set_ylabel(\"Transmittance\", fontsize=12)\nax.set_title(\"Transmittance vs Wavelength from Simulation 1\", fontsize=12)\nax.set_xlim(1100, 1600)\nax.set_ylim(0, 1.1)\nax.legend(loc=\"lower right\", fontsize=12)\n\n# work on the second figure\nax = axes[1]\nax.tick_params(axis=\"both\", labelsize=10)\nax.plot(td.C_0 / fr.freqs(N) * 1000, phase_rel, \"b\", lw=1, label=\"$\\phi$\")\nax.set_xlabel(r\"wavelength [$nm$]\", fontsize=12)\nax.set_ylabel(\"Phase [rad]\", fontsize=12)\nax.set_title(\"Phase Change vs Wavelength from Simulation 2\", fontsize=12)\nax.set_xlim(1100, 1600)\nax.set_ylim(0, np.pi*2)\nyticks = [0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi]\nytick_labels = [r\"$0$\", r\"$\\frac{\\pi}{2}$\", r\"$\\pi$\", \n                r\"$\\frac{3\\pi}{2}$\", r\"$2\\pi$\"]\nax.set_yticks(yticks)\nax.set_yticklabels(ytick_labels)\nax.legend()\n\nplt.savefig(\"huygens.png\", dpi=300)\n\n\n\n\n\n\n\n\n\n\nMesh Study\nHere, we set out to study the effect of different yee cell length on the transmittance.\n\ndls = [P/2, P/4, P/8, P/16, P/32, P/64, P/128] # mesh study list\nsims = {}\n\n\n# for each dl in dls\nfor i, dl in enumerate(dls):\n    # 2 Grid Specifications\n    horizontal_grid = td.UniformGrid(dl=dl)\n    vertical_grid = td.AutoGrid(min_steps_per_wvl=32)\n    grid_spec=td.GridSpec(\n        grid_x=horizontal_grid,\n        grid_y=horizontal_grid,\n        grid_z=vertical_grid,\n    )\n\n    # 4 Sources\n    source = td.PlaneWave(\n        source_time=fr.to_gaussian_pulse(),\n        size=(td.inf, td.inf, 0),\n        center=(0, 0, Lz/2 - spc + 2 * dl),\n        direction=\"-\",\n        pol_angle=0\n    )\n\n    # 5 Monitor\n    monitor = td.FluxMonitor(\n        center=(0, 0, -Lz/2 + spc - 2*dl),\n        size=(td.inf, td.inf, 0),\n        freqs=fr.freqs(N),\n        name=\"flux\"\n    )\n\n    sim_empty=td.Simulation(\n        size=sim_size,\n        grid_spec=grid_spec,\n        structures=[substrate, glass],\n        sources=[source],\n        monitors=[monitor],\n        run_time=run_time_short,\n        boundary_spec=bc\n    )\n\n    sim_actual = td.Simulation(\n        size=sim_size,\n        grid_spec=grid_spec,\n        structures=[substrate, glass, cylinder],\n        sources=[source],\n        monitors=[monitor],\n        run_time=run_time_short,\n        boundary_spec=bc\n    )\n\n    sims[f\"norm{i}\"] = sim_empty\n    sims[f\"actual{i}\"] = sim_actual  \n\n\n# verify the sims dictionary\nprint(sims.keys())\nbatch = web.Batch(simulations=sims, verbose=True)\n\ndict_keys(['norm0', 'actual0', 'norm1', 'actual1', 'norm2', 'actual2', 'norm3', 'actual3', 'norm4', 'actual4', 'norm5', 'actual5', 'norm6', 'actual6'])\n\n\n\n# run the simulations\nbatch_data = batch.run(path_dir=\"data\")\n\n\n\n\n\n\n\n02:21:47 EDT Started working on Batch containing 14 tasks.                      \n\n\n\n02:21:59 EDT Maximum FlexCredit cost: 0.392 for the whole batch.                \n\n\n\n             Use 'Batch.real_cost()' to get the billed FlexCredit cost after the\n             Batch has completed.                                               \n\n\n\n\n\n\n02:22:21 EDT Batch complete.                                                    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMesh Study Results\n\n# Extract results\nx = td.C_0 / fr.freqs(N) * 1000\nTs = []\nfor i in range(len(dls)):\n    Ts.append(batch_data[f\"actual{i}\"][\"flux\"].flux / batch_data[f\"norm{i}\"][\"flux\"].flux)\n\n\n# Plot results\nplt.figure(figsize=(10, 5))\nfor i, T in enumerate(Ts):\n    plt.plot(x, np.abs(T)**2, \"-\",lw=1, label=f\"dl={dls[i] * 1000:.1f} nm\")\nplt.xlabel(r\"Wavelength [$nm$]\", fontsize=12)\nplt.ylabel(r\"$|T|^2$\", fontsize=12)\nplt.xlim(1100, 1600)\nplt.ylim(-0.1, 1.1)\nplt.legend(fontsize=12)\nplt.tick_params(axis='both', labelsize=10) # change tick label size to 10\nplt.title(\"Transmission Spectra with Different Mesh Sizes\", fontsize=14)\nplt.savefig(\"mesh_convergence.png\", dpi=300)\nplt.show()",
    "crumbs": [
      "Simulation",
      "Huygens’ Surfaces"
    ]
  },
  {
    "objectID": "simulation/string_formatting.slides.html#old-style-string-formatting-with",
    "href": "simulation/string_formatting.slides.html#old-style-string-formatting-with",
    "title": "String Formatting",
    "section": "Old Style string formatting with %",
    "text": "Old Style string formatting with %\n\n# data type comes after a modulo sign\n# %s - string, and it is inside quotation marks\n# to assign value, you need to call % outside string\nprint(\"Hello, %s\" % \"Alex!\")\n\nHello Alex!\n\n\n\n# Use %d for integers and %f for floating point numbers\n# In order to insert multiple values, use a tuple\nname = \"Alex\"\nage = 20.2\nmoney = 1000.56789\n\nprint(\"%s is %d years old and has $%f.\" % (name, age, money))\n\nAlex is 20 years old and has $1000.567890.\n\n\n\n# Write it this way to be cleaner\nfstring = \"Hello %s, your current balance is $%f\"\ndata = (\"Alex\", 1000.56789)\nprint(fstring % data)\n\nHello Alex, your current balance is $1000.567890"
  },
  {
    "objectID": "simulation/string_formatting.slides.html#using-.format-method",
    "href": "simulation/string_formatting.slides.html#using-.format-method",
    "title": "String Formatting",
    "section": "Using .format() Method",
    "text": "Using .format() Method"
  },
  {
    "objectID": "simulation/string_formatting.slides.html#using-f-strings",
    "href": "simulation/string_formatting.slides.html#using-f-strings",
    "title": "String Formatting",
    "section": "Using f-strings",
    "text": "Using f-strings"
  },
  {
    "objectID": "simulation/string_formatting.slides.html#resources",
    "href": "simulation/string_formatting.slides.html#resources",
    "title": "String Formatting",
    "section": "Resources",
    "text": "Resources\n\nOld Style Tutorial\n.format() Method Tutorial\nfString Tutorial"
  },
  {
    "objectID": "simulation/string_formatting.html",
    "href": "simulation/string_formatting.html",
    "title": "String Formatting",
    "section": "",
    "text": "There are three ways to format strings:\n\n“Old style” string formatting\nUsing “.format()” Method\nUsing python f-strings\n\n\nOld Style string formatting with %\n\n# data type comes after a modulo sign\n# %s - string, and it is inside quotation marks\n# to assign value, you need to call % outside string\nprint(\"Hello, %s\" % \"Alex!\")\n\nHello Alex!\n\n\n\n# Use %d for integers and %f for floating point numbers\n# In order to insert multiple values, use a tuple\nname = \"Alex\"\nage = 20.2\nmoney = 1000.56789\n\nprint(\"%s is %d years old and has $%f.\" % (name, age, money))\n\nAlex is 20 years old and has $1000.567890.\n\n\n\n# Write it this way to be cleaner\nfstring = \"Hello %s, your current balance is $%f\"\ndata = (\"Alex\", 1000.56789)\nprint(fstring % data)\n\nHello Alex, your current balance is $1000.567890\n\n\n\n\nGeneral Arguments\n%[key][flags][width][.precision][length_type][conversion type] % [value]\n\n# Simplest string formatting\nprint(\"%s %s\" % (\"foo\", \"bar\"))\n\nfoo bar\n\n\n\n# Floats\n# %[type]\nprint(\"%f %f\" % (1, 2))\n\n1.000000 2.000000\n\n\n\n# Working with dictionaries\n# %([key])[type] -&gt; prints out [value]\ndct = {\"Alex\":20, 'Bob':18}\nprint(\"%(Alex)s\" % dct)\n\n20\n\n\n\n# We can specify the minimum width given to the inputs\n# width -&gt; how much space to reserve for the value\n# (C style programming)\n# 2 and 4 are widths\n# %[key][width][type]\n\nprint(\"Total number of students %4d\" % 3)\n\nTotal number of students    3\n\n\n\n# New type: %o - octal representation\nprint(\"Octal representation of %d is %o\" % (8, 8))\n\n# New type: %x - hexadecimal representation\nprint(\"Hexadecimal representation of %d is %x\" % (255, 255))\n\nOctal representation of 8 is 10\nHexadecimal representation of 255 is ff\n\n\nFlags:\n\n‘0’ - Pad with zeros\n‘-’ - Left align the value\n‘+’ - Always include the sign (+ or -)\n’ ’ - Leave a space before positive numbers\n\n\nprint(\"number %d\" % 3)      # %[type]\nprint(\"number %4d\" % 3)     # %[width][type]\nprint(\"number %04d\" % 3)    # %[flag][width][type]\n\nnumber 3\nnumber    3\nnumber 0003\n\n\n\nprint(\"%5d|\" % 1)   # right align the value\nprint(\"%-5d|\" % 1)  # left align the value\nprint(\"%0-5d|\" % 1)  # first flag will be overriden\n\n    1|\n1    |\n1    |\n\n\n\nprint(\"positive %d\" % 3) # space before positive number\nprint(\"positive % d\" % 3) # space before positive number\nprint(\"positive %  d\" % 3) # first space overriden by second space\nprint(\"negative %d\" % -3)\n\n# sign flags\nprint(\"number %d\" % +3)   # doesn't work\nprint(\"number %+d\" % 3)   # always show sign\n\npositive 3\npositive  3\npositive  3\nnegative -3\nnumber 3\nnumber +3\n\n\nprecision: For floating point numbers, this is the number of digits to show AFTER the decimal point.\n\n# %.[precision][type]\nprint(\"number %f\" % 3.14159)      # default precision is 6\nprint(\"number %.2f\" % 3.14159)    # precision\nprint(\"Your id is: %3d. Your score is %010.2f\" % (7, 3.14159))\n# 0 padding, width 10, precission 2\n\nnumber 3.141590\nnumber 3.14\nYour id is:   7. Your score is 0000003.14\n\n\n\n# New format: E is scientific notation\nprint(\"number %E\" % 1000000)\nprint(\"number %.2E\" % 1000000)  \n\nnumber 1.000000E+06\nnumber 1.00E+06\n\n\n\n# Precision with strings truncates the string\nprint(\"%.5s\" % \"HelloWorld\")  # Hello\n\nHello\n\n\n\n\n\nUsing .format() Method\n\n\nUsing f-strings\n\n\nResources\n\nOld Style Tutorial\n.format() Method Tutorial\nfString Tutorial",
    "crumbs": [
      "Python",
      "String Formatting"
    ]
  }
]